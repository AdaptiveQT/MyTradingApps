// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0
// © AEP Protocol v3 [STRATEGY] - Coach Eb Calibrated for Gold Backtesting

//@version=5
strategy("AEP Protocol v3 [STRATEGY]", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=2, currency=currency.USD, max_bars_back=1000, pyramiding=0, calc_on_every_tick=false, process_orders_on_close=true)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ STRATEGY SETTINGS ░░░
// ══════════════════════════════════════════════════════════════════════════════
grpStrat = "Strategy"
bool longEnabled = input.bool(true, "Enable Longs", group=grpStrat)
bool shortEnabled = input.bool(true, "Enable Shorts", group=grpStrat)
bool useSession = input.bool(true, "Only Trade During Session", group=grpStrat)
string tradeSession = input.session("0930-1600", "Trading Session (NY)", group=grpStrat)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ CORE SETTINGS (Coach Eb v3 Calibrated) ░░░
// ══════════════════════════════════════════════════════════════════════════════
grpCore = "Core"
string maType = input.string("EMA", "MA Type", options=["EMA", "SMA", "WMA", "VWMA"], group=grpCore)
int fastLen = input.int(9, "Fast MA", minval=1, group=grpCore)
int slowLen = input.int(30, "Slow MA", minval=1, group=grpCore)
int rsiLen = input.int(14, "RSI Length", minval=2, group=grpCore)
int rsiOB = input.int(70, "RSI Overbought", minval=50, group=grpCore)
int rsiOS = input.int(25, "RSI Oversold", minval=0, group=grpCore)
bool enableMomentumLongs = input.bool(true, "Enable Momentum Longs", group=grpCore)
bool enableMomentumShorts = input.bool(true, "Enable Momentum Shorts", group=grpCore)
bool simpleColorway = input.bool(false, "Simple Colorway Mode", group=grpCore, tooltip="Beginner mode: Just MA bias")

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ CHOP SETTINGS ░░░
// ══════════════════════════════════════════════════════════════════════════════
grpChop = "Consolidation"
float consolEMAPct = input.float(0.4, "Consolidation EMA %", minval=0.1, step=0.1, group=grpChop)
float consolMaxMovePct = input.float(0.6, "Consolidation Max Price Move %", minval=0.1, step=0.1, group=grpChop)
int rangeBarCount = input.int(20, "Range Bar Count", minval=5, group=grpChop)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ ORB SETTINGS ░░░
// ══════════════════════════════════════════════════════════════════════════════
grpORB = "Breakouts"
bool orbEnabled = input.bool(true, "Enable ORB", group=grpORB)
string orbSession = input.session("0930-0945", "ORB Session (NY)", group=grpORB)
int orbHoldBars = input.int(15, "ORB Breakout Hold Bars", minval=1, group=grpORB)
bool blockCounterTrend = input.bool(true, "Block counter-trend during ORB", group=grpORB)
float orbRetestTol = input.float(30.0, "ORB Retest Tolerance %", minval=1.0, group=grpORB)
int maxBarsRetest = input.int(25, "Max Bars After ORB For Retest", minval=5, group=grpORB)
int maxBarsFakeout = input.int(15, "Max Bars for Fakeout Detection", minval=1, group=grpORB)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ ADVANCED SETTINGS (Coach Eb Calibrated) ░░░
// ══════════════════════════════════════════════════════════════════════════════
grpAdv = "Advanced"
int volumePeriod = input.int(8, "Volume Period", minval=1, group=grpAdv, tooltip="Coach Eb uses 8-10")
float momentumBodyMult = input.float(1.2, "Momentum Body Multiplier", minval=0.5, step=0.1, group=grpAdv, tooltip="Coach Eb uses 1.1-1.2")

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ RISK SETTINGS ░░░
// ══════════════════════════════════════════════════════════════════════════════
grpRisk = "Risk"
float profitFactor = input.float(2.0, "Profit Factor (ATR mult)", minval=0.5, step=0.5, group=grpRisk)
float stopFactor = input.float(1.0, "Stop Factor (ATR mult)", minval=0.5, step=0.5, group=grpRisk)
bool useLunarMult = input.bool(true, "Apply Lunar Multiplier to Targets", group=grpRisk)
float lunarStrength = input.float(1.0, "Lunar Strength", minval=0.5, maxval=2.0, step=0.1, group=grpRisk)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ CALCULATIONS ░░░
// ══════════════════════════════════════════════════════════════════════════════
ma(src, len, t) =>
    switch t
        "EMA" => ta.ema(src, len)
        "SMA" => ta.sma(src, len)
        "WMA" => ta.wma(src, len)
        "VWMA" => ta.vwma(src, len)
        => ta.ema(src, len)

float fastMA = ma(close, fastLen, maType)
float slowMA = ma(close, slowLen, maType)
float rsiVal = ta.rsi(close, rsiLen)

// Alignment
bool fastUp = fastMA > fastMA[3]
bool slowUp = slowMA > slowMA[3]
bool fastDn = fastMA < fastMA[3]
bool slowDn = slowMA < slowMA[3]
bool bullAlign = fastMA > slowMA and fastUp and slowUp
bool bearAlign = fastMA < slowMA and fastDn and slowDn

// Chop Detection
float maDistPct = (math.abs(fastMA - slowMA) / close) * 100
float rangeHi = ta.highest(high, rangeBarCount)
float rangeLo = ta.lowest(low, rangeBarCount)
float rangeMovePct = ((rangeHi - rangeLo) / rangeLo) * 100
bool isChop = maDistPct < consolEMAPct or rangeMovePct < consolMaxMovePct

// Momentum Logic
float avgVol = ta.sma(volume, volumePeriod)
bool volConfirm = volume > avgVol

float bodySize = math.abs(close - open)
float avgBody = ta.sma(bodySize, 3)
bool strongBody = bodySize > avgBody * momentumBodyMult
bool breakPrevHigh = close > high[1]
bool breakPrevLow = close < low[1]

bool pullbackLong = bullAlign and close < fastMA and close > slowMA
bool pullbackShort = bearAlign and close > fastMA and close < slowMA

// RSI Momentum (Coach Eb integration)
bool rsiLongMomo = rsiVal < rsiOS and enableMomentumLongs
bool rsiShortMomo = rsiVal > rsiOB and enableMomentumShorts

// Session Check
bool inSession = useSession ? not na(time(timeframe.period, tradeSession, "America/New_York")) : true

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ ORB LOGIC ░░░
// ══════════════════════════════════════════════════════════════════════════════
bool inORB = time(timeframe.period, orbSession, "America/New_York")
var float orbHigh = na
var float orbLow = na
var bool orbComplete = false
var int orbBarStart = na
var int orbDayKey = na

if dayofweek != orbDayKey
    orbHigh := na
    orbLow := na
    orbComplete := false
    orbBarStart := na
    orbDayKey := dayofweek

if inORB and orbEnabled
    orbHigh := na(orbHigh) ? high : math.max(orbHigh, high)
    orbLow := na(orbLow) ? low : math.min(orbLow, low)
    if na(orbBarStart)
        orbBarStart := bar_index
    if not na(orbHigh) and not na(orbLow)
        orbComplete := true

var int orbBreakDir = 0
var int orbBreakBar = na

if orbComplete and not inORB and orbEnabled
    if ta.crossover(close, orbHigh) and orbBreakDir == 0
        orbBreakDir := 1
        orbBreakBar := bar_index
    if ta.crossunder(close, orbLow) and orbBreakDir == 0
        orbBreakDir := -1
        orbBreakBar := bar_index

if dayofweek != dayofweek[1]
    orbBreakDir := 0
    orbBreakBar := na

int barsSinceBreak = na(orbBreakBar) ? 999 : bar_index - orbBreakBar

// ORB Retest Detection
bool inRetestWindow = barsSinceBreak <= maxBarsRetest
float retestTolAmt = (orbHigh - orbLow) * (orbRetestTol / 100)
bool orbRetestLong = orbBreakDir == 1 and inRetestWindow and low <= orbHigh + retestTolAmt and low >= orbHigh - retestTolAmt
bool orbRetestShort = orbBreakDir == -1 and inRetestWindow and high >= orbLow - retestTolAmt and high <= orbLow + retestTolAmt

// ORB Midline & Fakeout
var float orbMid = na
if orbComplete
    orbMid := math.avg(orbHigh, orbLow)

bool inFakeoutWindow = barsSinceBreak <= maxBarsFakeout
bool fakeoutLong = orbBreakDir == 1 and inFakeoutWindow and close < orbMid
bool fakeoutShort = orbBreakDir == -1 and inFakeoutWindow and close > orbMid

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ LUNAR MODULE ░░░
// ══════════════════════════════════════════════════════════════════════════════
lunarAge() =>
    int y = year
    int m = month
    int d = dayofmonth
    if m <= 2
        y := y - 1
        m := m + 12
    int A = math.floor(y / 100)
    int B = 2 - A + math.floor(A / 4)
    float JD = math.floor(365.25 * (y + 4716)) + math.floor(30.6001 * (m + 1)) + d + B - 1524.5
    float age = (JD - 2451550.1) % 29.53058867
    if age < 0
        age := age + 29.53058867
    age

float moonAge = lunarAge()
float volMult = useLunarMult ? ((moonAge < 1.85 or moonAge >= 27.69 or (moonAge >= 14.77 and moonAge < 16.61)) ? 1.5 * lunarStrength : (moonAge >= 7.38 and moonAge < 9.23) or (moonAge >= 22.15 and moonAge < 23.99) ? 1.0 * lunarStrength : 1.25 * lunarStrength) : 1.0

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ SIGNAL LOGIC (Coach Eb v3 Complete) ░░░
// ══════════════════════════════════════════════════════════════════════════════

// Long conditions (RSI integrated into momentum)
bool longBase = bullAlign and not isChop and close > fastMA and volConfirm and strongBody
bool longMomo = bullAlign and close > fastMA and strongBody and breakPrevHigh and not isChop and enableMomentumLongs and rsiLongMomo
bool longPullbackEntry = pullbackLong[1] and close > fastMA and not isChop
bool longRetestEntry = orbRetestLong and bullAlign and not isChop
bool longSignal = (longBase or longMomo or longPullbackEntry or longRetestEntry)

// Short conditions (RSI integrated into momentum)
bool shortBase = bearAlign and not isChop and close < fastMA and volConfirm and strongBody
bool shortMomo = bearAlign and close < fastMA and strongBody and breakPrevLow and not isChop and enableMomentumShorts and rsiShortMomo
bool shortPullbackEntry = pullbackShort[1] and close < fastMA and not isChop
bool shortRetestEntry = orbRetestShort and bearAlign and not isChop
bool shortSignal = (shortBase or shortMomo or shortPullbackEntry or shortRetestEntry)

// Simple Colorway Mode
if simpleColorway
    longSignal := bullAlign and close > fastMA
    shortSignal := bearAlign and close < fastMA

// Fakeout Gate
if not simpleColorway and barsSinceBreak <= maxBarsFakeout
    if fakeoutLong
        longSignal := false
    if fakeoutShort
        shortSignal := false

// ORB Gate
if not simpleColorway and blockCounterTrend and orbEnabled and orbComplete and barsSinceBreak <= orbHoldBars
    if orbBreakDir == 1
        shortSignal := false
    if orbBreakDir == -1
        longSignal := false

// Chop Block
if not simpleColorway and isChop
    longSignal := false
    shortSignal := false

// Session Filter
if useSession and not inSession
    longSignal := false
    shortSignal := false

// Enable Filters
longSignal := longSignal and longEnabled
shortSignal := shortSignal and shortEnabled

// Duplicate Block
longSignal := longSignal and not longSignal[1]
shortSignal := shortSignal and not shortSignal[1]

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ STRATEGY EXECUTION ░░░
// ══════════════════════════════════════════════════════════════════════════════
float atrVal = ta.atr(14)

// ENTRY
if longSignal and strategy.position_size == 0
    strategy.entry("Long", strategy.long, comment="AEP L")
    
if shortSignal and strategy.position_size == 0
    strategy.entry("Short", strategy.short, comment="AEP S")

// EXIT LOGIC (ATR Dynamic with Lunar Multiplier)
if strategy.position_size > 0
    float entryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)
    float lStop = entryPrice - (atrVal * stopFactor)
    float lTarget = entryPrice + (atrVal * profitFactor * volMult)
    strategy.exit("Exit Long", "Long", stop=lStop, limit=lTarget, comment_loss="SL", comment_profit="TP")

if strategy.position_size < 0
    float entryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)
    float sStop = entryPrice + (atrVal * stopFactor)
    float sTarget = entryPrice - (atrVal * profitFactor * volMult)
    strategy.exit("Exit Short", "Short", stop=sStop, limit=sTarget, comment_loss="SL", comment_profit="TP")

// REVERSAL LOGIC
if longSignal and strategy.position_size < 0
    strategy.close("Short", comment="Flip L")
    strategy.entry("Long", strategy.long, comment="AEP L (Flip)")

if shortSignal and strategy.position_size > 0
    strategy.close("Long", comment="Flip S")
    strategy.entry("Short", strategy.short, comment="AEP S (Flip)")

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ VISUALS ░░░
// ══════════════════════════════════════════════════════════════════════════════
plot(fastMA, "Fast MA", color=color.blue)
plot(slowMA, "Slow MA", color=color.orange)
bgcolor(isChop ? color.new(color.gray, 90) : bullAlign ? color.new(color.green, 92) : bearAlign ? color.new(color.red, 92) : na)

// Signal markers
plotshape(longSignal, style=shape.labelup, location=location.belowbar, color=color.green, text="L", textcolor=color.white, size=size.small)
plotshape(shortSignal, style=shape.labeldown, location=location.abovebar, color=color.red, text="S", textcolor=color.white, size=size.small)

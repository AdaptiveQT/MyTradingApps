// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0
// Â© ICT x Zodiac Protocol [STRATEGY] - Backtestable Version

//@version=5
strategy("ICT x Zodiac [STRATEGY]", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=2, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.01)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ STRATEGY SETTINGS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpStrat = "Strategy Settings"
float riskPercent = input.float(1.0, "Risk %", minval=0.1, maxval=5, step=0.1, group=grpStrat)
float rrRatio = input.float(2.0, "Risk:Reward", minval=1.0, maxval=5.0, step=0.5, group=grpStrat)
bool useZodiacFilter = input.bool(true, "Use Zodiac Alignment Filter", group=grpStrat, tooltip="Only trade when zodiac element aligns with signal direction")
bool onlyStrongZones = input.bool(true, "Only Trade Strong â˜… Zones", group=grpStrat)
bool sbOnly = input.bool(false, "Only Trade During Killzones", group=grpStrat)

grpSession = "Session Filter"
bool tradeLondon = input.bool(true, "Trade London", group=grpSession)
string londonTime = input.string("0200-0500", "London Time", group=grpSession, tooltip="Format: HHMM-HHMM (NY time)")
bool tradeNY = input.bool(true, "Trade NY AM", group=grpSession)
string nyTime = input.string("0700-1000", "NY AM Time", group=grpSession)
bool tradeSB = input.bool(true, "Trade Silver Bullet", group=grpSession)
string sbTime = input.string("1000-1100", "Silver Bullet Time", group=grpSession, tooltip="ICT's high-probability window")

bool useHTFFilter = input.bool(true, "Use HTF Trend Filter", group=grpHTF, tooltip="Only trade in direction of higher timeframe trend")
string htfTimeframe = input.string("60", "HTF Timeframe", options=["15", "30", "60", "240", "D"], group=grpHTF)
int htfEmaLen = input.int(50, "HTF EMA Length", minval=10, maxval=200, group=grpHTF)

grpICT = "ICT Structure"
int structLen = input.int(5, "Structure Lookback", minval=3, group=grpICT)
int maxFVG = input.int(3, "Max FVGs", minval=1, maxval=20, group=grpICT)
int maxOB = input.int(3, "Max Order Blocks", minval=1, maxval=10, group=grpICT)
bool showBOS = input.bool(true, "Show BOS", group=grpICT)

grpOBScore = "Scored OB Settings"
int obScoreThreshold = input.int(5, "Min OB Score (0-10)", minval=0, maxval=10, group=grpOBScore)
float obATRMult = input.float(2.0, "Strong Move ATR Mult", minval=1.0, step=0.5, group=grpOBScore)
bool showOBScore = input.bool(true, "Show OB Score", group=grpOBScore)
bool hideWeakOBs = input.bool(false, "Hide Weak OBs", group=grpOBScore)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 1. ZODIAC CALCULATION â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
int moonOffset = input.int(10, "Moon Degree Offset", group="Zodiac")

lunarAge() =>
    int y = year
    int m = month
    int d = dayofmonth
    if m <= 2
        y := y - 1
        m := m + 12
    int A = math.floor(y / 100)
    int B = 2 - A + math.floor(A / 4)
    float JD = math.floor(365.25 * (y + 4716)) + math.floor(30.6001 * (m + 1)) + d + B - 1524.5
    float age = (JD - 2451550.1 + moonOffset) % 29.53058867
    if age < 0
        age := age + 29.53058867
    age

float moonAge = lunarAge()
string[] zodiacSigns = array.from("Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo", "Libra", "Scorpio", "Sagittarius", "Capricorn", "Aquarius", "Pisces")
int zodiacIdx = math.floor((moonAge / 29.53) * 12) % 12
string currentZodiac = array.get(zodiacSigns, zodiacIdx)

string[] fireSigns = array.from("Aries", "Leo", "Sagittarius")
string[] earthSigns = array.from("Taurus", "Virgo", "Capricorn")
string[] airSigns = array.from("Gemini", "Libra", "Aquarius")
string[] waterSigns = array.from("Cancer", "Scorpio", "Pisces")

bool isFire = array.includes(fireSigns, currentZodiac)
bool isWater = array.includes(waterSigns, currentZodiac)
bool isAir = array.includes(airSigns, currentZodiac)
bool isEarth = array.includes(earthSigns, currentZodiac)

// Zodiac Bias
// FIRE = Expansion (favor longs in uptrend)
// WATER = Manipulation (favor fades/shorts)
// AIR = Consolidation (scalp both)
// EARTH = Structure (deep pullback entries)
bool bullishBias = isFire or isEarth
bool bearishBias = isWater or isAir

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 2. KILLZONE DETECTION â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool inLondon = not na(time(timeframe.period, londonTime, "America/New_York"))
bool inNY = not na(time(timeframe.period, nyTime, "America/New_York"))
bool inSB = not na(time(timeframe.period, sbTime, "America/New_York"))

bool inTradingSession = (tradeLondon and inLondon) or (tradeNY and inNY) or (tradeSB and inSB)
bool inKillzone = inLondon or inNY or inSB

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 3. FVG DETECTION â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool isBullFVG = low > high[2]
bool isBearFVG = high < low[2]

// Strength Detection
float avgRange = ta.sma(high - low, 14)
float fvgGapBull = isBullFVG ? (low - high[2]) : 0
float fvgGapBear = isBearFVG ? (low[2] - high) : 0
float dispBody = math.abs(close[1] - open[1])
float avgBody = ta.sma(math.abs(close - open), 14)

bool hasDisplacement = dispBody > avgBody * 1.5
bool strongBullFVG = isBullFVG and fvgGapBull > avgRange * 0.3 and hasDisplacement
bool strongBearFVG = isBearFVG and fvgGapBear > avgRange * 0.3 and hasDisplacement

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 4. HTF TREND FILTER â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float htfEma = request.security(syminfo.tickerid, htfTimeframe, ta.ema(close, htfEmaLen), lookahead=barmerge.lookahead_on)
bool htfBullish = close > htfEma
bool htfBearish = close < htfEma

// Plot HTF EMA for reference
plot(useHTFFilter ? htfEma : na, "HTF EMA", color=color.new(color.purple, 50), linewidth=2)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 5. ORDER BLOCK SCORING â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// OB Tracking Arrays
var box[] bullOBs = array.new_box()
var box[] bearOBs = array.new_box()
var float[] bullOBBots = array.new_float()
var float[] bearOBTops = array.new_float()
var int[] bullOBScores = array.new_int()
var int[] bearOBScores = array.new_int()
var box[] bullFVGs = array.new_box()
var box[] bearFVGs = array.new_box()
var float[] bullFVGTops = array.new_float()
var float[] bullFVGBots = array.new_float()
var int[] bullFVGScores = array.new_int()
var float[] bearFVGTops = array.new_float()
var float[] bearFVGBots = array.new_float()
var int[] bearFVGScores = array.new_int()

// FVG Confluence Check Function
fvgNearOB(obTop, obBot, isBull) =>
    bool hasConfluence = false
    if isBull and array.size(bullFVGTops) > 0
        for i = 0 to array.size(bullFVGTops) - 1
            fvgTop = array.get(bullFVGTops, i)
            fvgBot = array.get(bullFVGBots, i)
            if (fvgBot <= obTop and fvgTop >= obBot)
                hasConfluence := true
    if not isBull and array.size(bearFVGTops) > 0
        for i = 0 to array.size(bearFVGTops) - 1
            fvgTop = array.get(bearFVGTops, i)
            fvgBot = array.get(bearFVGBots, i)
            if (fvgBot <= obTop and fvgTop >= obBot)
                hasConfluence := true
    hasConfluence

// OB Scoring Function (0-10)
calcOBScore(obBody, displacement, inKZ, htfAligned, hasFVG) =>
    int score = 0
    // +3 Strong displacement (move > 2x ATR)
    if displacement > atrVal * obATRMult
        score += 3
    // +2 First test (unmitigated)
    score += 2
    // +2 HTF trend aligned
    if htfAligned
        score += 2
    // +1 In killzone
    if inKZ
        score += 1
    // +1 FVG confluence
    if hasFVG
        score += 1
    // +1 Strong body
    score += 1
    math.min(score, 10)

// Helper for OB color
obColorByScore(score, isBull) =>
    if score >= 8
        isBull ? color.new(#00ff88, 60) : color.new(#ff4444, 60)
    else if score >= 5
        isBull ? color.new(#00bcd4, 70) : color.new(#ff5252, 70)
    else
        color.new(color.gray, 80)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 6. DETAILED LOGIC (OBs, PO3, JUDAS, OTE) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ SCORED OB CREATION â”€â”€â”€
// Use pivots for BOS
float sh = ta.pivothigh(high, structLen, structLen)
float sl = ta.pivotlow(low, structLen, structLen)
var float lastSH = na, var float lastSL = na
if not na(sh)
    lastSH := sh
if not na(sl)
    lastSL := sl

bool crossHigh = ta.crossover(close, lastSH)
bool crossLow = ta.crossunder(close, lastSL)
bool bosUp = not na(lastSH) and crossHigh
bool bosDn = not na(lastSL) and crossLow

// Create Bull OBs
if bosUp
    int idx = na
    for i = 1 to 10
        if close[i] < open[i]
            idx := i
            break
    if not na(idx)
        float obTop = high[idx]
        float obBot = low[idx]
        float obBody = math.abs(close[idx] - open[idx])
        float displacement = math.abs(close - close[idx])
        bool hasFVG = fvgNearOB(obTop, obBot, true)
        int obScore = calcOBScore(obBody, displacement, inKillzone, htfBullish, hasFVG)
        
        array.push(bullOBs, box.new(bar_index, obTop, bar_index, obBot)) 
        array.push(bullOBBots, obBot)
        array.push(bullOBScores, obScore)
        if array.size(bullOBs) > maxOB
            array.shift(bullOBs) // cleanup
            array.shift(bullOBBots)
            array.shift(bullOBScores)

// Create Bear OBs
if bosDn
    int idx = na
    for i = 1 to 10
        if close[i] > open[i]
            idx := i
            break
    if not na(idx)
        float obTop = high[idx]
        float obBot = low[idx]
        float obBody = math.abs(close[idx] - open[idx])
        float displacement = math.abs(close - close[idx])
        bool hasFVG = fvgNearOB(obTop, obBot, false)
        int obScore = calcOBScore(obBody, displacement, inKillzone, htfBearish, hasFVG)
        
        array.push(bearOBs, box.new(bar_index, obTop, bar_index, obBot))
        array.push(bearOBTops, obTop)
        array.push(bearOBScores, obScore)
        if array.size(bearOBs) > maxOB
            array.shift(bearOBs)
            array.shift(bearOBTops)
            array.shift(bearOBScores)

// â”€â”€â”€ PO3 / AMD CYCLE â”€â”€â”€
float po3Fast = ta.ema(close, 9)
float po3Slow = ta.ema(close, 21)
bool po3Uptrend = po3Fast > po3Slow
float swingHigh = ta.highest(high, structLen)
float swingLow = ta.lowest(low, structLen)

bool isAccumulation = po3Uptrend and close < po3Slow and close > swingLow * 0.995
bool isManipulation = (high > swingHigh[1] and close < open) or (low < swingLow[1] and close > open)
bool isDistribution = (po3Uptrend and close > po3Fast * 1.005) or (not po3Uptrend and close < po3Fast * 0.995)

var string po3Phase = "NEUTRAL"
if isManipulation and inKillzone
    po3Phase := "MANIPULATION"
else if isAccumulation
    po3Phase := "ACCUMULATION"
else if isDistribution
    po3Phase := "DISTRIBUTION"

// â”€â”€â”€ JUDAS SWING â”€â”€â”€
bool judasBearTrap = low < swingLow[1] and close > swingLow[1] and close > open and inKillzone
bool judasBullTrap = high > swingHigh[1] and close < swingHigh[1] and close < open and inKillzone

// â”€â”€â”€ OTE ZONE â”€â”€â”€
int oteLookback = structLen * 3
float oteSwingHigh = ta.highest(high, oteLookback)
float oteSwingLow = ta.lowest(low, oteLookback)
float oteRange = oteSwingHigh - oteSwingLow
float ote62Bull = oteSwingHigh - oteRange * 0.62
float ote79Bull = oteSwingHigh - oteRange * 0.79
float ote62Bear = oteSwingLow + oteRange * 0.62
float ote79Bear = oteSwingLow + oteRange * 0.79

bool inBullOTE = close >= ote79Bull and close <= ote62Bull and htfBullish
bool inBearOTE = close >= ote62Bear and close <= ote79Bear and htfBearish

// â”€â”€â”€ NUCLEAR PROXIMITY CHECK â”€â”€â”€
float nucATR = ta.atr(14)
bool nearBullZone = false
bool nearBearZone = false

// Check OBs
if array.size(bullOBScores) > 0
    for i = 0 to array.size(bullOBScores) - 1
        if array.get(bullOBScores, i) >= obScoreThreshold
            if math.abs(close - array.get(bullOBBots, i)) < nucATR * 0.5
                nearBullZone := true
if array.size(bearOBScores) > 0
    for i = 0 to array.size(bearOBScores) - 1
        if array.get(bearOBScores, i) >= obScoreThreshold
            if math.abs(close - array.get(bearOBTops, i)) < nucATR * 0.5
                nearBearZone := true

// â”€â”€â”€ SIGNALS â”€â”€â”€
// Base Signals (FVG + Disp)
float bodySize = math.abs(close - open)
float avgBody = ta.sma(bodySize, 14)
bool disp = bodySize > avgBody * 1.5
bool kzLongBase = inKillzone and strongBullFVG and disp
bool kzShortBase = inKillzone and strongBearFVG and disp

// Nuclear Logic
// AEP logic (Fast/Slow MA alignment) from Protocol
float fastMA = ta.ema(close, 21) // Simplified for strategy
float slowMA = ta.ema(close, 50)
bool aepBull = fastMA > slowMA
bool aepBear = fastMA < slowMA

bool nuclearLong = kzLongBase and aepBull and nearBullZone
bool nuclearShort = kzShortBase and aepBear and nearBearZone

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 7. EXECUTION â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ENTRY CONDITIONS
// 1. Nuclear Signal (Strongest)
// 2. OTE + Killzone + FVG (High Prob)
// 3. Judas Rejection (Advanced)

bool entryLong = nuclearLong or (inBullOTE and kzLongBase) or (judasBearTrap and aepBull)
bool entryShort = nuclearShort or (inBearOTE and kzShortBase) or (judasBullTrap and aepBear)

// FILTERING
if useZodiacFilter
    entryLong := entryLong and bullishBias
    entryShort := entryShort and bearishBias

if onlyStrongZones
    // Implied by nearBullZone check in Nuclear, but enforce for others
    entryLong := entryLong // simplified for now

// EXECUTION
if entryLong
    strategy.entry("Long", strategy.long, comment="ğŸš€ " + (nuclearLong ? "NUCLEAR" : "OTE/KZ"))
if entryShort
    strategy.entry("Short", strategy.short, comment="ğŸš€ " + (nuclearShort ? "NUCLEAR" : "OTE/KZ"))

// EXITS
// Fixed RR or Opposite Signal
if strategy.position_size > 0
    if entryShort or judasBullTrap // Close on opposite signal
        strategy.close("Long", comment="Reversal")
    // Stop/Target handled by strategy.exit? No, need to calculate price
    // Stop/Target
    float stopPrice = not na(lastSL) ? lastSL : low - ta.atr(14)
    float targetPrice = close + (close - stopPrice) * rrRatio
    strategy.exit("Exit Long", "Long", stop=stopPrice, limit=targetPrice)

if strategy.position_size < 0
    if entryLong or judasBearTrap
        strategy.close("Short", comment="Reversal")
    float stopPriceShort = not na(lastSH) ? lastSH : high + ta.atr(14)
    float targetPriceShort = close - (stopPriceShort - close) * rrRatio
    strategy.exit("Exit Short", "Short", stop=stopPriceShort, limit=targetPriceShort)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 8. DASHBOARD â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var table dash = table.new(position.top_right, 2, 8, bgcolor=color.new(color.black, 70), border_width=1)
if barstate.islast
    table.cell(dash, 0, 0, "STRATEGY MODE", text_color=color.white, bgcolor=color.blue)
    table.merge_cells(dash, 0, 0, 1, 0)
    table.cell(dash, 0, 1, "Element", text_color=color.white)
    table.cell(dash, 1, 1, currentZodiac, text_color=color.yellow)
    table.cell(dash, 0, 2, "Phase", text_color=color.white)
    table.cell(dash, 1, 2, po3Phase, text_color=color.gray)
    table.cell(dash, 0, 3, "OTE", text_color=color.white)
    table.cell(dash, 1, 3, inBullOTE ? "BULL" : inBearOTE ? "BEAR" : "OFF", text_color=color.purple)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ ALERTS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(entryLong, title="Strategy LONG", message="ğŸš€ ZODIAC LONG ENTRY")
alertcondition(entryShort, title="Strategy SHORT", message="ğŸš€ ZODIAC SHORT ENTRY")

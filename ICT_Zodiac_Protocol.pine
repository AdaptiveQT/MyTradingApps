// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0
// Â© ICT x AEP Protocol [NUCLEAR] - Confluence Trading System

//@version=5
indicator("ICT x AEP [NUCLEAR]", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ MASTER TOGGLES â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpMaster = "Master Toggles"
bool showKillzones = input.bool(true, "Show Killzones", group=grpMaster)
bool showPivots = input.bool(true, "Show Pivots", group=grpMaster)
bool showPDLevels = input.bool(true, "Show PDH/PDL/PWH/PWL", group=grpMaster)
bool showFVG = input.bool(true, "Show FVGs", group=grpMaster)
bool showOB = input.bool(true, "Show Order Blocks", group=grpMaster)
bool showBOS = input.bool(true, "Show Break of Structure", group=grpMaster)
bool showZodiac = input.bool(true, "Show Zodiac Dashboard", group=grpMaster)
bool presentMode = input.bool(true, "Present Mode (Fresh Zones Only)", group=grpMaster, tooltip="When ON, removes FVGs/OBs when price fills them")
bool zodiacFilter = input.bool(true, "Zodiac Signal Filter", group=grpMaster, tooltip="Only show signals when zodiac aligns with direction")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ CONFLUENCE SETTINGS (AEP + ICT) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpConfl = "ğŸ”¥ Confluence (AEP + ICT)"
bool enableConfluence = input.bool(true, "Enable Confluence Detection", group=grpConfl)
int fastLen = input.int(9, "Fast MA Length", minval=1, group=grpConfl)
int slowLen = input.int(21, "Slow MA Length", minval=1, group=grpConfl)
int rsiLen = input.int(14, "RSI Length", minval=1, group=grpConfl)
float rsiOB = input.float(70, "RSI Overbought", group=grpConfl)
float rsiOS = input.float(30, "RSI Oversold", group=grpConfl)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ KILLZONE SETTINGS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpKZ = "Killzones"
bool showKZBoxes = input.bool(true, "Show Killzone Boxes", group=grpKZ)
bool showKZText = input.bool(true, "Display Text", inline="kzdisp", group=grpKZ)
bool showKZOpen = input.bool(true, "Show KZ Open Lines", group=grpKZ)
int kzTransparency = input.int(70, "Box Transparency", minval=0, maxval=100, group=grpKZ)

grpAsia = "Asia"
bool showAsiaKZ = input.bool(true, "", inline="asia", group=grpAsia)
string asiaStart = input.string("20:00", "Start", inline="asia", group=grpAsia)
string asiaEnd = input.string("00:00", "End", inline="asia", group=grpAsia)
color asiaCol = input.color(color.blue, "", inline="asia", group=grpAsia)

grpLondon = "London"
bool showLondonKZ = input.bool(true, "", inline="ldn", group=grpLondon)
string londonStart = input.string("02:00", "Start", inline="ldn", group=grpLondon)
string londonEnd = input.string("05:00", "End", inline="ldn", group=grpLondon)
color londonCol = input.color(color.red, "", inline="ldn", group=grpLondon)

grpNYAM = "NY AM"
bool showNYKZ = input.bool(true, "", inline="nyam", group=grpNYAM)
string nyStart = input.string("09:30", "Start", inline="nyam", group=grpNYAM)
string nyEnd = input.string("11:00", "End", inline="nyam", group=grpNYAM)
color nyCol = input.color(color.teal, "", inline="nyam", group=grpNYAM)

grpNYLunch = "NY Lunch"
bool showNYLunch = input.bool(true, "", inline="nylunch", group=grpNYLunch)
string nyLunchStart = input.string("12:00", "Start", inline="nylunch", group=grpNYLunch)
string nyLunchEnd = input.string("13:00", "End", inline="nylunch", group=grpNYLunch)
color nyLunchCol = input.color(color.orange, "", inline="nylunch", group=grpNYLunch)

grpNYPM = "NY PM"
bool showNYPM = input.bool(true, "", inline="nypm", group=grpNYPM)
string nyPMStart = input.string("13:30", "Start", inline="nypm", group=grpNYPM)
string nyPMEnd = input.string("16:00", "End", inline="nypm", group=grpNYPM)
color nyPMCol = input.color(color.purple, "", inline="nypm", group=grpNYPM)

grpSilverBullet = "Silver Bullet (10-11 AM)"
bool showSilverBullet = input.bool(true, "", inline="sb", group=grpSilverBullet, tooltip="ICT's high-probability 10:00-11:00 AM NY window")
string sbStart = input.string("10:00", "Start", inline="sb", group=grpSilverBullet)
string sbEnd = input.string("11:00", "End", inline="sb", group=grpSilverBullet)
color sbCol = input.color(color.lime, "", inline="sb", group=grpSilverBullet)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ PIVOT SETTINGS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpPivot = "Pivots"
bool showDailyPivots = input.bool(true, "Daily Pivots", group=grpPivot)
bool showWeeklyPivots = input.bool(false, "Weekly Pivots", group=grpPivot)
string pivotType = input.string("Traditional", "Type", options=["Traditional", "Fibonacci", "Camarilla"], group=grpPivot)
color pivotCol = input.color(color.orange, "Pivot (P)", group=grpPivot)
color rCol = input.color(color.red, "R Levels", group=grpPivot)
color sCol = input.color(color.green, "S Levels", group=grpPivot)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ ICT STRUCTURE SETTINGS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpICT = "ICT Structure"
int structLen = input.int(5, "Structure Lookback", minval=3, group=grpICT)
int maxFVG = input.int(3, "Max FVGs", minval=1, maxval=20, group=grpICT)
int maxOB = input.int(3, "Max Order Blocks", minval=1, maxval=10, group=grpICT)
color bullFvgCol = input.color(color.new(#089981, 85), "Bull FVG", group=grpICT)
color bearFvgCol = input.color(color.new(#f23645, 85), "Bear FVG", group=grpICT)
color bullObCol = input.color(color.new(#00bcd4, 80), "Bull OB", group=grpICT)
color bearObCol = input.color(color.new(#ff5252, 80), "Bear OB", group=grpICT)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ ORDER BLOCK SCORING â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpOBScore = "OB Scoring"
int obScoreThreshold = input.int(5, "Min OB Score (0-10)", minval=0, maxval=10, group=grpOBScore, tooltip="Only show OBs scoring above this")
float obATRMult = input.float(2.0, "Displacement ATR Mult", minval=1.0, step=0.5, group=grpOBScore, tooltip="Move away must exceed this * ATR")
bool showOBScore = input.bool(true, "Show OB Score", group=grpOBScore)
bool hideWeakOBs = input.bool(false, "Hide Weak OBs", group=grpOBScore, tooltip="Hide OBs below threshold instead of graying out")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ FVG SCORING â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpFVGScore = "FVG Scoring"
int fvgScoreThreshold = input.int(5, "Min FVG Score (0-10)", minval=0, maxval=10, group=grpFVGScore, tooltip="Only show FVGs scoring above this")
float fvgATRMult = input.float(2.0, "Displacement ATR Mult", minval=1.0, step=0.5, group=grpFVGScore)
bool showFVGScore = input.bool(true, "Show FVG Score", group=grpFVGScore)
bool hideWeakFVGs = input.bool(false, "Hide Weak FVGs", group=grpFVGScore)
bool detectIFVG = input.bool(true, "Detect Inverse FVGs (iFVG)", group=grpFVGScore, tooltip="Mark FVGs that get breached as inverse")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ ZODIAC SETTINGS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpAstro = "Zodiac"
int moonOffset = input.int(10, "Moon Degree Offset", group=grpAstro)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 1. ZODIAC CALCULATION â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
lunarAge() =>
    int y = year
    int m = month
    int d = dayofmonth
    if m <= 2
        y := y - 1
        m := m + 12
    int A = math.floor(y / 100)
    int B = 2 - A + math.floor(A / 4)
    float JD = math.floor(365.25 * (y + 4716)) + math.floor(30.6001 * (m + 1)) + d + B - 1524.5
    float age = (JD - 2451550.1 + moonOffset) % 29.53058867
    if age < 0
        age := age + 29.53058867
    age

float moonAge = lunarAge()
string[] zodiacSigns = array.from("Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo", "Libra", "Scorpio", "Sagittarius", "Capricorn", "Aquarius", "Pisces")
int zodiacIdx = math.floor((moonAge / 29.53) * 12) % 12
string currentZodiac = array.get(zodiacSigns, zodiacIdx)

string moonPhase = moonAge < 1.85 ? "ğŸŒ‘ New" : moonAge < 7.38 ? "ğŸŒ’ Wax Cres" : moonAge < 11.07 ? "ğŸŒ“ 1st Qtr" : moonAge < 14.76 ? "ğŸŒ” Wax Gib" : moonAge < 16.61 ? "ğŸŒ• Full" : moonAge < 22.14 ? "ğŸŒ– Wan Gib" : moonAge < 25.83 ? "ğŸŒ— 3rd Qtr" : "ğŸŒ˜ Wan Cres"

string element = "Neutral"
string ictBias = "Balanced"
string ictFocus = "Standard"
color elemCol = color.gray

string[] fireSigns = array.from("Aries", "Leo", "Sagittarius")
string[] earthSigns = array.from("Taurus", "Virgo", "Capricorn")
string[] airSigns = array.from("Gemini", "Libra", "Aquarius")
string[] waterSigns = array.from("Cancer", "Scorpio", "Pisces")

if array.includes(fireSigns, currentZodiac)
    element := "ğŸ”¥ FIRE"
    ictBias := "EXPANSION"
    ictFocus := "Trust BOS & FVGs"
    elemCol := color.orange
else if array.includes(waterSigns, currentZodiac)
    element := "ğŸ’§ WATER"
    ictBias := "MANIPULATION"
    ictFocus := "Fade Liq Grabs"
    elemCol := color.aqua
else if array.includes(airSigns, currentZodiac)
    element := "ğŸŒªï¸ AIR"
    ictBias := "CONSOLIDATION"
    ictFocus := "Scalp IRL"
    elemCol := color.silver
else if array.includes(earthSigns, currentZodiac)
    element := "ğŸŒ EARTH"
    ictBias := "STRUCTURE"
    ictFocus := "Deep OTE"
    elemCol := color.green

// Zodiac Bias for filtering
bool bullishBias = array.includes(fireSigns, currentZodiac) or array.includes(earthSigns, currentZodiac)
bool bearishBias = array.includes(waterSigns, currentZodiac) or array.includes(airSigns, currentZodiac)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 2. KILLZONE DETECTION â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Helper function to convert time strings to session format
asiaTimeStr = str.replace(asiaStart, ":", "") + "-" + str.replace(asiaEnd, ":", "")
londonTimeStr = str.replace(londonStart, ":", "") + "-" + str.replace(londonEnd, ":", "")
nyTimeStr = str.replace(nyStart, ":", "") + "-" + str.replace(nyEnd, ":", "")
nyLunchTimeStr = str.replace(nyLunchStart, ":", "") + "-" + str.replace(nyLunchEnd, ":", "")
nyPMTimeStr = str.replace(nyPMStart, ":", "") + "-" + str.replace(nyPMEnd, ":", "")
sbTimeStr = str.replace(sbStart, ":", "") + "-" + str.replace(sbEnd, ":", "")

bool inAsia = not na(time(timeframe.period, asiaTimeStr, "America/New_York"))
bool inLondon = not na(time(timeframe.period, londonTimeStr, "America/New_York"))
bool inNY = not na(time(timeframe.period, nyTimeStr, "America/New_York"))
bool inNYLunch = not na(time(timeframe.period, nyLunchTimeStr, "America/New_York"))
bool inNYPM = not na(time(timeframe.period, nyPMTimeStr, "America/New_York"))
bool inSilverBullet = not na(time(timeframe.period, sbTimeStr, "America/New_York"))

bool asiaSessionStart = inAsia and not inAsia[1]
bool londonSessionStart = inLondon and not inLondon[1]
bool nySessionStart = inNY and not inNY[1]
bool nyLunchSessionStart = inNYLunch and not inNYLunch[1]
bool nyPMSessionStart = inNYPM and not inNYPM[1]
bool sbSessionStart = inSilverBullet and not inSilverBullet[1]

// Session tracking
var float asiaOpen = na, var float londonOpen = na, var float nyOpen = na, var float nyLunchOpen = na, var float nyPMOpen = na, var float sbOpen = na
var float asiaHigh = na, var float asiaLow = na
var float londonHigh = na, var float londonLow = na
var float nyHigh = na, var float nyLow = na
var float nyLunchHigh = na, var float nyLunchLow = na
var float nyPMHigh = na, var float nyPMLow = na
var float sbHigh = na, var float sbLow = na
var int asiaStartBar = na, var int londonStartBar = na, var int nyStartBar = na, var int nyLunchStartBar = na, var int nyPMStartBar = na, var int sbStartBar = na

// Asia
if asiaSessionStart
    asiaOpen := open, asiaHigh := high, asiaLow := low, asiaStartBar := bar_index
if inAsia
    asiaHigh := math.max(asiaHigh, high), asiaLow := math.min(asiaLow, low)

// London  
if londonSessionStart
    londonOpen := open, londonHigh := high, londonLow := low, londonStartBar := bar_index
if inLondon
    londonHigh := math.max(londonHigh, high), londonLow := math.min(londonLow, low)

// NY AM
if nySessionStart
    nyOpen := open, nyHigh := high, nyLow := low, nyStartBar := bar_index
if inNY
    nyHigh := math.max(nyHigh, high), nyLow := math.min(nyLow, low)

// NY Lunch
if nyLunchSessionStart
    nyLunchOpen := open, nyLunchHigh := high, nyLunchLow := low, nyLunchStartBar := bar_index
if inNYLunch
    nyLunchHigh := math.max(nyLunchHigh, high), nyLunchLow := math.min(nyLunchLow, low)

// NY PM
if nyPMSessionStart
    nyPMOpen := open, nyPMHigh := high, nyPMLow := low, nyPMStartBar := bar_index
if inNYPM
    nyPMHigh := math.max(nyPMHigh, high), nyPMLow := math.min(nyPMLow, low)

// â•â•â• KILLZONE BOXES â•â•â•
var box asiaBox = na, var box londonBox = na, var box nyBox = na, var box nyLunchBox = na, var box nyPMBox = na
var line asiaHighLine = na, var line asiaLowLine = na
var line londonHighLine = na, var line londonLowLine = na
var line nyHighLine = na, var line nyLowLine = na
var line nyLunchHighLine = na, var line nyLunchLowLine = na
var line nyPMHighLine = na, var line nyPMLowLine = na
var label asiaLabel = na, var label londonLabel = na, var label nyLabel = na, var label nyLunchLabel = na, var label nyPMLabel = na

// Update boxes dynamically during session
if showKillzones and showKZBoxes and showAsiaKZ and inAsia
    box.delete(asiaBox)
    label.delete(asiaLabel)
    asiaBox := box.new(asiaStartBar, asiaHigh, bar_index, asiaLow, border_color=asiaCol, bgcolor=color.new(asiaCol, kzTransparency), border_width=1)
    if showKZText
        asiaLabel := label.new(asiaStartBar, asiaHigh, "ASIA", style=label.style_none, textcolor=asiaCol, size=size.small)

if showKillzones and showKZBoxes and showLondonKZ and inLondon
    box.delete(londonBox)
    label.delete(londonLabel)
    londonBox := box.new(londonStartBar, londonHigh, bar_index, londonLow, border_color=londonCol, bgcolor=color.new(londonCol, kzTransparency), border_width=1)
    if showKZText
        londonLabel := label.new(londonStartBar, londonHigh, "LONDON", style=label.style_none, textcolor=londonCol, size=size.small)

if showKillzones and showKZBoxes and showNYKZ and inNY
    box.delete(nyBox)
    label.delete(nyLabel)
    nyBox := box.new(nyStartBar, nyHigh, bar_index, nyLow, border_color=nyCol, bgcolor=color.new(nyCol, kzTransparency), border_width=1)
    if showKZText
        nyLabel := label.new(nyStartBar, nyHigh, "NY AM", style=label.style_none, textcolor=nyCol, size=size.small)

if showKillzones and showKZBoxes and showNYLunch and inNYLunch
    box.delete(nyLunchBox)
    label.delete(nyLunchLabel)
    nyLunchBox := box.new(nyLunchStartBar, nyLunchHigh, bar_index, nyLunchLow, border_color=nyLunchCol, bgcolor=color.new(nyLunchCol, kzTransparency), border_width=1)
    if showKZText
        nyLunchLabel := label.new(nyLunchStartBar, nyLunchHigh, "NY LUNCH", style=label.style_none, textcolor=nyLunchCol, size=size.small)

if showKillzones and showKZBoxes and showNYPM and inNYPM
    box.delete(nyPMBox)
    label.delete(nyPMLabel)
    nyPMBox := box.new(nyPMStartBar, nyPMHigh, bar_index, nyPMLow, border_color=nyPMCol, bgcolor=color.new(nyPMCol, kzTransparency), border_width=1)
    if showKZText
        nyPMLabel := label.new(nyPMStartBar, nyPMHigh, "NY PM", style=label.style_none, textcolor=nyPMCol, size=size.small)

// KZ Open lines (dotted through session)
plot(showKZOpen and showAsiaKZ and inAsia ? asiaOpen : na, "Asia Open", asiaCol, style=plot.style_linebr)
plot(showKZOpen and showLondonKZ and inLondon ? londonOpen : na, "LDN Open", londonCol, style=plot.style_linebr)
plot(showKZOpen and showNYKZ and inNY ? nyOpen : na, "NY Open", nyCol, style=plot.style_linebr)
plot(showKZOpen and showNYLunch and inNYLunch ? nyLunchOpen : na, "NY Lunch Open", nyLunchCol, style=plot.style_linebr)
plot(showKZOpen and showNYPM and inNYPM ? nyPMOpen : na, "NY PM Open", nyPMCol, style=plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 3. PIVOTS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[dHigh, dLow, dClose] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)

calcPivots(h, l, c, pType) =>
    float p = (h + l + c) / 3
    float r1 = 0.0, float r2 = 0.0, float s1 = 0.0, float s2 = 0.0
    if pType == "Traditional"
        r1 := (2 * p) - l, s1 := (2 * p) - h
        r2 := p + (h - l), s2 := p - (h - l)
    else if pType == "Fibonacci"
        r1 := p + 0.382 * (h - l), s1 := p - 0.382 * (h - l)
        r2 := p + 0.618 * (h - l), s2 := p - 0.618 * (h - l)
    else if pType == "Camarilla"
        r1 := c + (h - l) * 1.1 / 12, s1 := c - (h - l) * 1.1 / 12
        r2 := c + (h - l) * 1.1 / 6, s2 := c - (h - l) * 1.1 / 6
    [p, r1, r2, s1, s2]

[dP, dR1, dR2, dS1, dS2] = calcPivots(dHigh, dLow, dClose, pivotType)

plot(showPivots and showDailyPivots ? dP : na, "Pivot", pivotCol, style=plot.style_circles, linewidth=2)
plot(showPivots and showDailyPivots ? dR1 : na, "R1", rCol, style=plot.style_cross)
plot(showPivots and showDailyPivots ? dR2 : na, "R2", color.new(rCol, 40), style=plot.style_cross)
plot(showPivots and showDailyPivots ? dS1 : na, "S1", sCol, style=plot.style_cross)
plot(showPivots and showDailyPivots ? dS2 : na, "S2", color.new(sCol, 40), style=plot.style_cross)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 4. PDH/PDL/PWH/PWL â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float pdh = request.security(syminfo.tickerid, "D", high[1], lookahead=barmerge.lookahead_on)
float pdl = request.security(syminfo.tickerid, "D", low[1], lookahead=barmerge.lookahead_on)
float pwh = request.security(syminfo.tickerid, "W", high[1], lookahead=barmerge.lookahead_on)
float pwl = request.security(syminfo.tickerid, "W", low[1], lookahead=barmerge.lookahead_on)

// Horizontal lines for PDH/PDL/PWH/PWL
var line pdhLine = na, var line pdlLine = na, var line pwhLine = na, var line pwlLine = na
var label pdhLabel = na, var label pdlLabel = na, var label pwhLabel = na, var label pwlLabel = na

if showPDLevels and barstate.islast
    // Delete old lines
    line.delete(pdhLine), line.delete(pdlLine), line.delete(pwhLine), line.delete(pwlLine)
    label.delete(pdhLabel), label.delete(pdlLabel), label.delete(pwhLabel), label.delete(pwlLabel)
    
    // PDH/PDL
    pdhLine := line.new(bar_index - 100, pdh, bar_index + 20, pdh, color=color.red, style=line.style_solid, width=2)
    pdlLine := line.new(bar_index - 100, pdl, bar_index + 20, pdl, color=color.green, style=line.style_solid, width=2)
    pdhLabel := label.new(bar_index + 22, pdh, "PDH", style=label.style_none, textcolor=color.red, size=size.small)
    pdlLabel := label.new(bar_index + 22, pdl, "PDL", style=label.style_none, textcolor=color.green, size=size.small)
    
    // PWH/PWL
    pwhLine := line.new(bar_index - 100, pwh, bar_index + 20, pwh, color=color.fuchsia, style=line.style_dashed, width=1)
    pwlLine := line.new(bar_index - 100, pwl, bar_index + 20, pwl, color=color.aqua, style=line.style_dashed, width=1)
    pwhLabel := label.new(bar_index + 22, pwh, "PWH", style=label.style_none, textcolor=color.fuchsia, size=size.small)
    pwlLabel := label.new(bar_index + 22, pwl, "PWL", style=label.style_none, textcolor=color.aqua, size=size.small)

// â•â•â• LIQUIDITY SWEEP DETECTION â•â•â•
// Wick beyond PDH/PDL but close back inside = liquidity grab
bool pdhSweep = high > pdh and close < pdh  // Swept PDH, closed below
bool pdlSweep = low < pdl and close > pdl   // Swept PDL, closed above
bool pwhSweep = high > pwh and close < pwh  // Swept PWH
bool pwlSweep = low < pwl and close > pwl   // Swept PWL

// Note: Liquidity sweep labels plotted in signals section after inKillzone is defined

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 5. FVG DETECTION (INTELLIGENT SCORING + iFVG) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool isBullFVG = low > high[2]
bool isBearFVG = high < low[2]

// Strength Detection
float avgRange = ta.sma(high - low, 14)
float fvgGapBull = isBullFVG ? (low - high[2]) : 0
float fvgGapBear = isBearFVG ? (low[2] - high) : 0
float dispBody = math.abs(close[1] - open[1])
float avgBody = ta.sma(math.abs(close - open), 14)
float fvgATR = ta.atr(14)

// Killzone check (includes Silver Bullet)
bool inKillzone = inAsia or inLondon or inNY or inNYLunch or inNYPM or inSilverBullet
bool hasDisplacement = dispBody > avgBody * 1.5

// HTF Trend for FVG alignment (reuse from later if available, or calculate here)
float fvgFastEMA = ta.ema(close, 9)
float fvgSlowEMA = ta.ema(close, 21)
bool fvgHtfBullTrend = fvgFastEMA > fvgSlowEMA
bool fvgHtfBearTrend = fvgFastEMA < fvgSlowEMA

// FVG Scoring Function (0-10)
calcFVGScore(gapSize, displacement, inKZ, htfAligned, isLargeGap) =>
    int score = 0
    // +3 Strong displacement (middle candle > 2x ATR)
    if displacement > fvgATR * fvgATRMult
        score += 3
    // +2 Unmitigated (all new FVGs are unmitigated)
    score += 2
    // +2 HTF trend aligned
    if htfAligned
        score += 2
    // +1 In killzone
    if inKZ
        score += 1
    // +1 Large gap size
    if isLargeGap
        score += 1
    // +1 Strong body displacement
    if displacement > avgBody * 1.5
        score += 1
    math.min(score, 10)

// FVG Color by Score
fvgColorByScore(score, isBull) =>
    if score >= 8
        isBull ? color.new(#00ff88, 60) : color.new(#ff4444, 60)  // Bright
    else if score >= 5
        isBull ? color.new(#089981, 70) : color.new(#f23645, 70)  // Normal
    else
        color.new(color.gray, 80)  // Weak

// FVG Tracking Arrays
var box[] bullFVGs = array.new_box()
var box[] bearFVGs = array.new_box()
var float[] bullFVGTops = array.new_float()
var float[] bullFVGBots = array.new_float()
var float[] bearFVGTops = array.new_float()
var float[] bearFVGBots = array.new_float()
var int[] bullFVGScores = array.new_int()
var int[] bearFVGScores = array.new_int()

// iFVG Tracking
var box[] iFVGs = array.new_box()

// Create Bull FVG with Scoring
if showFVG and isBullFVG
    float fvgTop = low
    float fvgBot = high[2]
    bool isLargeGap = fvgGapBull > avgRange * 0.3
    int fvgScore = calcFVGScore(fvgGapBull, dispBody, inKillzone, fvgHtfBullTrend, isLargeGap)
    
    // Apply threshold filter
    if fvgScore >= fvgScoreThreshold or not hideWeakFVGs
        string fvgLabel = showFVGScore ? "â–® FVG " + str.tostring(fvgScore) + "/10" : "â–® FVG"
        if fvgScore >= 8
            fvgLabel := fvgLabel + " â˜…"
        int bWidth = fvgScore >= 8 ? 3 : fvgScore >= 5 ? 2 : 1
        color bCol = fvgColorByScore(fvgScore, true)
        color borderCol = fvgScore >= 5 ? color.new(#089981, 30) : color.new(color.gray, 40)
        
        box b = box.new(bar_index[2], fvgTop, bar_index + 50, fvgBot, border_color=borderCol, bgcolor=bCol, border_width=bWidth, text=fvgLabel, text_color=#089981, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
        array.push(bullFVGs, b)
        array.push(bullFVGTops, fvgTop)
        array.push(bullFVGBots, fvgBot)
        array.push(bullFVGScores, fvgScore)
        if array.size(bullFVGs) > maxFVG
            box.delete(array.shift(bullFVGs))
            array.shift(bullFVGTops)
            array.shift(bullFVGBots)
            array.shift(bullFVGScores)

// Create Bear FVG with Scoring
if showFVG and isBearFVG
    float fvgTop = low[2]
    float fvgBot = high
    bool isLargeGap = fvgGapBear > avgRange * 0.3
    int fvgScore = calcFVGScore(fvgGapBear, dispBody, inKillzone, fvgHtfBearTrend, isLargeGap)
    
    // Apply threshold filter
    if fvgScore >= fvgScoreThreshold or not hideWeakFVGs
        string fvgLabel = showFVGScore ? "â–® FVG " + str.tostring(fvgScore) + "/10" : "â–® FVG"
        if fvgScore >= 8
            fvgLabel := fvgLabel + " â˜…"
        int bWidth = fvgScore >= 8 ? 3 : fvgScore >= 5 ? 2 : 1
        color bCol = fvgColorByScore(fvgScore, false)
        color borderCol = fvgScore >= 5 ? color.new(#f23645, 30) : color.new(color.gray, 40)
        
        box b = box.new(bar_index[2], fvgTop, bar_index + 50, fvgBot, border_color=borderCol, bgcolor=bCol, border_width=bWidth, text=fvgLabel, text_color=#f23645, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
        array.push(bearFVGs, b)
        array.push(bearFVGTops, fvgTop)
        array.push(bearFVGBots, fvgBot)
        array.push(bearFVGScores, fvgScore)
        if array.size(bearFVGs) > maxFVG
            box.delete(array.shift(bearFVGs))
            array.shift(bearFVGTops)
            array.shift(bearFVGBots)
            array.shift(bearFVGScores)

// â•â•â• FVG MITIGATION + iFVG DETECTION â•â•â•
if presentMode and array.size(bullFVGs) > 0
    for i = array.size(bullFVGs) - 1 to 0
        if i < array.size(bullFVGBots)
            float bot = array.get(bullFVGBots, i)
            float top = array.get(bullFVGTops, i)
            // Bull FVG breached completely = create iFVG (bearish)
            if close < bot
                if detectIFVG
                    // Create iFVG (inverse - now bearish resistance)
                    box iFvg = box.new(bar_index - 5, top, bar_index + 30, bot, border_color=color.new(color.orange, 20), bgcolor=color.new(color.orange, 80), border_width=2, text="iFVG â†“", text_color=color.orange, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
                    array.push(iFVGs, iFvg)
                    if array.size(iFVGs) > maxFVG
                        box.delete(array.shift(iFVGs))
                // Remove original
                box.delete(array.get(bullFVGs, i))
                array.remove(bullFVGs, i)
                array.remove(bullFVGTops, i)
                array.remove(bullFVGBots, i)
                if i < array.size(bullFVGScores)
                    array.remove(bullFVGScores, i)

if presentMode and array.size(bearFVGs) > 0
    for i = array.size(bearFVGs) - 1 to 0
        if i < array.size(bearFVGTops)
            float top = array.get(bearFVGTops, i)
            float bot = array.get(bearFVGBots, i)
            // Bear FVG breached completely = create iFVG (bullish)
            if close > top
                if detectIFVG
                    // Create iFVG (inverse - now bullish support)
                    box iFvg = box.new(bar_index - 5, top, bar_index + 30, bot, border_color=color.new(color.orange, 20), bgcolor=color.new(color.orange, 80), border_width=2, text="iFVG â†‘", text_color=color.orange, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
                    array.push(iFVGs, iFvg)
                    if array.size(iFVGs) > maxFVG
                        box.delete(array.shift(iFVGs))
                // Remove original
                box.delete(array.get(bearFVGs, i))
                array.remove(bearFVGs, i)
                array.remove(bearFVGTops, i)
                array.remove(bearFVGBots, i)
                if i < array.size(bearFVGScores)
                    array.remove(bearFVGScores, i)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 6. ORDER BLOCKS (INTELLIGENT SCORING) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float sh = ta.pivothigh(high, structLen, structLen)
float sl = ta.pivotlow(low, structLen, structLen)
var float lastSH = na, var float lastSL = na
if not na(sh)
    lastSH := sh
if not na(sl)
    lastSL := sl

bool crossHigh = ta.crossover(close, lastSH)
bool crossLow = ta.crossunder(close, lastSL)
bool bosUp = not na(lastSH) and crossHigh
bool bosDn = not na(lastSL) and crossLow

if showBOS and bosUp
    label.new(bar_index, high, "BOSâ†‘", color=color.new(color.green, 100), style=label.style_label_down, textcolor=color.lime, size=size.tiny)
if showBOS and bosDn
    label.new(bar_index, low, "BOSâ†“", color=color.new(color.red, 100), style=label.style_label_up, textcolor=color.red, size=size.tiny)

// OB Tracking Arrays
var box[] bullOBs = array.new_box()
var box[] bearOBs = array.new_box()
var float[] bullOBBots = array.new_float()
var float[] bearOBTops = array.new_float()
var int[] bullOBScores = array.new_int()
var int[] bearOBScores = array.new_int()

// ATR & Body for scoring (avgBody reused from line 349)
float atrVal = ta.atr(14)
float bodySize = math.abs(close - open)

// HTF Trend Detection (Fast EMA > Slow EMA = bullish)
float htfFastEMA = ta.ema(close, fastLen)
float htfSlowEMA = ta.ema(close, slowLen)
bool htfBullTrend = htfFastEMA > htfSlowEMA
bool htfBearTrend = htfFastEMA < htfSlowEMA

// FVG Confluence Check Function
fvgNearOB(obTop, obBot, isBull) =>
    bool hasConfluence = false
    if isBull and array.size(bullFVGTops) > 0
        for i = 0 to array.size(bullFVGTops) - 1
            fvgTop = array.get(bullFVGTops, i)
            fvgBot = array.get(bullFVGBots, i)
            if (fvgBot <= obTop and fvgTop >= obBot)
                hasConfluence := true
    if not isBull and array.size(bearFVGTops) > 0
        for i = 0 to array.size(bearFVGTops) - 1
            fvgTop = array.get(bearFVGTops, i)
            fvgBot = array.get(bearFVGBots, i)
            if (fvgBot <= obTop and fvgTop >= obBot)
                hasConfluence := true
    hasConfluence

// OB Scoring Function (0-10)
calcOBScore(obBody, displacement, inKZ, htfAligned, hasFVG) =>
    int score = 0
    // +3 Strong displacement (move > 2x ATR)
    if displacement > atrVal * obATRMult
        score += 3
    // +2 First test (unmitigated - all new OBs are unmitigated)
    score += 2
    // +2 HTF trend aligned
    if htfAligned
        score += 2
    // +1 In killzone
    if inKZ
        score += 1
    // +1 FVG confluence
    if hasFVG
        score += 1
    // +1 Strong body
    if obBody > avgBody * 1.3
        score += 1
    math.min(score, 10)

// OB Color by Score
obColorByScore(score, isBull) =>
    if score >= 8
        isBull ? color.new(#00ff88, 60) : color.new(#ff4444, 60)  // Green/Red - High
    else if score >= 5
        isBull ? color.new(#00bcd4, 70) : color.new(#ff5252, 70)  // Cyan/Pink - Medium
    else
        color.new(color.gray, 80)  // Gray - Weak

// Create Bull OB with Scoring
if showOB and bosUp
    int idx = na
    for i = 1 to 10
        if close[i] < open[i]
            idx := i
            break
    if not na(idx)
        float obTop = high[idx]
        float obBot = low[idx]
        float obBody = math.abs(close[idx] - open[idx])
        float displacement = math.abs(close - close[idx])
        bool hasFVG = fvgNearOB(obTop, obBot, true)
        int obScore = calcOBScore(obBody, displacement, inKillzone, htfBullTrend, hasFVG)
        
        // Apply threshold filter
        if obScore >= obScoreThreshold or not hideWeakOBs
            string obLabel = showOBScore ? "â–® OB " + str.tostring(obScore) + "/10" : "â–® OB"
            if obScore >= 8
                obLabel := obLabel + " â˜…"
            int obWidth = obScore >= 8 ? 3 : obScore >= 5 ? 2 : 1
            color obBgCol = obColorByScore(obScore, true)
            color obBorderCol = obScore >= 5 ? color.new(#00bcd4, 20) : color.new(color.gray, 40)
            
            box b = box.new(bar_index - idx, obTop, bar_index + 60, obBot, border_color=obBorderCol, bgcolor=obBgCol, border_width=obWidth, text=obLabel, text_color=#00bcd4, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
            array.push(bullOBs, b)
            array.push(bullOBBots, obBot)
            array.push(bullOBScores, obScore)
            if array.size(bullOBs) > maxOB
                box.delete(array.shift(bullOBs))
                array.shift(bullOBBots)
                array.shift(bullOBScores)

// Create Bear OB with Scoring
if showOB and bosDn
    int idx = na
    for i = 1 to 10
        if close[i] > open[i]
            idx := i
            break
    if not na(idx)
        float obTop = high[idx]
        float obBot = low[idx]
        float obBody = math.abs(close[idx] - open[idx])
        float displacement = math.abs(close - close[idx])
        bool hasFVG = fvgNearOB(obTop, obBot, false)
        int obScore = calcOBScore(obBody, displacement, inKillzone, htfBearTrend, hasFVG)
        
        // Apply threshold filter
        if obScore >= obScoreThreshold or not hideWeakOBs
            string obLabel = showOBScore ? "â–® OB " + str.tostring(obScore) + "/10" : "â–® OB"
            if obScore >= 8
                obLabel := obLabel + " â˜…"
            int obWidth = obScore >= 8 ? 3 : obScore >= 5 ? 2 : 1
            color obBgCol = obColorByScore(obScore, false)
            color obBorderCol = obScore >= 5 ? color.new(#ff5252, 20) : color.new(color.gray, 40)
            
            box b = box.new(bar_index - idx, obTop, bar_index + 60, obBot, border_color=obBorderCol, bgcolor=obBgCol, border_width=obWidth, text=obLabel, text_color=#ff5252, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
            array.push(bearOBs, b)
            array.push(bearOBTops, obTop)
            array.push(bearOBScores, obScore)
            if array.size(bearOBs) > maxOB
                box.delete(array.shift(bearOBs))
                array.shift(bearOBTops)
                array.shift(bearOBScores)

// â•â•â• ORDER BLOCK MITIGATION (Present Mode) â•â•â•
if presentMode and array.size(bullOBs) > 0
    for i = array.size(bullOBs) - 1 to 0
        if i < array.size(bullOBBots)
            float bot = array.get(bullOBBots, i)
            // Bull OB invalidated when price closes below
            if close < bot
                box.delete(array.get(bullOBs, i))
                array.remove(bullOBs, i)
                array.remove(bullOBBots, i)
                if i < array.size(bullOBScores)
                    array.remove(bullOBScores, i)

if presentMode and array.size(bearOBs) > 0
    for i = array.size(bearOBs) - 1 to 0
        if i < array.size(bearOBTops)
            float top = array.get(bearOBTops, i)
            // Bear OB invalidated when price closes above
            if close > top
                box.delete(array.get(bearOBs, i))
                array.remove(bearOBs, i)
                array.remove(bearOBTops, i)
                if i < array.size(bearOBScores)
                    array.remove(bearOBScores, i)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 7. KILLZONE SIGNALS (ZODIAC FILTERED) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// bodySize reused from line 450
bool disp = bodySize > avgBody * 1.5

// Base killzone signals
bool kzLongBase = inKillzone and isBullFVG and disp and close > open
bool kzShortBase = inKillzone and isBearFVG and disp and close < open

// Apply zodiac filter if enabled
bool kzLong = zodiacFilter ? (kzLongBase and bullishBias) : kzLongBase
bool kzShort = zodiacFilter ? (kzShortBase and bearishBias) : kzShortBase

// Strong signals (high score FVG + displacement + killzone aligned)
// Note: strongBullFVG/strongBearFVG replaced with hasDisplacement + killzone check
bool kzLongStrong = kzLong and hasDisplacement and inKillzone
bool kzShortStrong = kzShort and hasDisplacement and inKillzone

// Visual differentiation: Strong = â˜…, Weak = standard
plotshape(kzLongStrong, style=shape.labelup, location=location.belowbar, color=color.green, text="KZ â˜…", textcolor=color.white, size=size.normal)
plotshape(kzLong and not kzLongStrong, style=shape.labelup, location=location.belowbar, color=color.new(color.green, 40), text="KZ", textcolor=color.white, size=size.small)
plotshape(kzShortStrong, style=shape.labeldown, location=location.abovebar, color=color.red, text="KZ â˜…", textcolor=color.white, size=size.normal)
plotshape(kzShort and not kzShortStrong, style=shape.labeldown, location=location.abovebar, color=color.new(color.red, 40), text="KZ", textcolor=color.white, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 7B. CONFLUENCE DETECTION (AEP + ICT) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AEP-style trend detection
float fastMA = ta.ema(close, fastLen)
float slowMA = ta.ema(close, slowLen)
float rsiVal = ta.rsi(close, rsiLen)

// MA alignment (AEP style)
bool fastUp = fastMA > fastMA[3]
bool fastDn = fastMA < fastMA[3]
bool slowUp = slowMA > slowMA[3]
bool slowDn = slowMA < slowMA[3]
bool aepBullAlign = fastMA > slowMA and fastUp and slowUp
bool aepBearAlign = fastMA < slowMA and fastDn and slowDn

// RSI confirmation
bool rsiNotOB = rsiVal < rsiOB  // Not overbought for longs
bool rsiNotOS = rsiVal > rsiOS  // Not oversold for shorts

// â•â•â• OB/FVG PROXIMITY CHECK FOR NUCLEAR â•â•â•
// Check if price is within 0.5 ATR of a high-score OB or FVG
float nuclearATR = ta.atr(14)
bool nearHighScoreBullOB = false
bool nearHighScoreBearOB = false
bool nearHighScoreBullFVG = false
bool nearHighScoreBearFVG = false

// Check bull OBs for proximity
if array.size(bullOBScores) > 0
    for i = 0 to array.size(bullOBScores) - 1
        if array.get(bullOBScores, i) >= obScoreThreshold
            float obBot = array.get(bullOBBots, i)
            if math.abs(close - obBot) < nuclearATR * 0.5
                nearHighScoreBullOB := true

// Check bear OBs for proximity
if array.size(bearOBScores) > 0
    for i = 0 to array.size(bearOBScores) - 1
        if array.get(bearOBScores, i) >= obScoreThreshold
            float obTop = array.get(bearOBTops, i)
            if math.abs(close - obTop) < nuclearATR * 0.5
                nearHighScoreBearOB := true

// Check FVGs for proximity
if array.size(bullFVGScores) > 0
    for i = 0 to array.size(bullFVGScores) - 1
        if array.get(bullFVGScores, i) >= fvgScoreThreshold
            float fvgBot = array.get(bullFVGBots, i)
            if math.abs(close - fvgBot) < nuclearATR * 0.5
                nearHighScoreBullFVG := true

if array.size(bearFVGScores) > 0
    for i = 0 to array.size(bearFVGScores) - 1
        if array.get(bearFVGScores, i) >= fvgScoreThreshold
            float fvgTop = array.get(bearFVGTops, i)
            if math.abs(close - fvgTop) < nuclearATR * 0.5
                nearHighScoreBearFVG := true

bool nearBullZone = nearHighScoreBullOB or nearHighScoreBullFVG
bool nearBearZone = nearHighScoreBearOB or nearHighScoreBearFVG

// â•â•â• NUCLEAR CONFLUENCE â•â•â•
// Both AEP (trend) and ICT (structure) agree on STRONG signals
// Enhanced: Require proximity to high-score OB/FVG
bool nuclearLong = enableConfluence and kzLongStrong and aepBullAlign and rsiNotOB and nearBullZone
bool nuclearShort = enableConfluence and kzShortStrong and aepBearAlign and rsiNotOS and nearBearZone

// Visual: Diamond marker for nuclear confluence
plotshape(nuclearLong, style=shape.diamond, location=location.belowbar, color=color.new(#FFD700, 0), text="ğŸ”¥ NUCLEAR", textcolor=color.white, size=size.large, offset=-1)
plotshape(nuclearShort, style=shape.diamond, location=location.abovebar, color=color.new(#FFD700, 0), text="ğŸ”¥ NUCLEAR", textcolor=color.white, size=size.large, offset=-1)

// Conflict detection (AEP and ICT disagree)
bool conflictLong = kzLongStrong and aepBearAlign  // ICT says long, AEP says bearish
bool conflictShort = kzShortStrong and aepBullAlign  // ICT says short, AEP says bullish

// â•â•â• CONFLICT WARNING LABELS â•â•â•
plotshape(conflictLong, style=shape.xcross, location=location.belowbar, color=color.new(color.orange, 0), text="âš  CONFLICT", textcolor=color.orange, size=size.small)
plotshape(conflictShort, style=shape.xcross, location=location.abovebar, color=color.new(color.orange, 0), text="âš  CONFLICT", textcolor=color.orange, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ POWER OF 3 (PO3) â€“ AMD CYCLE â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Accumulation â†’ Manipulation â†’ Distribution (core ICT cycle)

// PO3 EMAs for trend context
float po3Fast = ta.ema(close, 9)
float po3Slow = ta.ema(close, 21)
bool po3Uptrend = po3Fast > po3Slow

// Swing High/Low for structure (use existing structLen)
float swingHigh = ta.highest(high, structLen)
float swingLow = ta.lowest(low, structLen)

// Phase detection based on price action + trend
var string po3Phase = "NEUTRAL"
var string prevPO3Phase = "NEUTRAL"

// Accumulation: Price consolidating below resistance in uptrend (smart money loading)
bool isAccumulation = po3Uptrend and close < po3Slow and close > swingLow * 0.995

// Manipulation: False move / Judas swing (wick beyond structure then reversal)
bool isManipulation = (high > swingHigh[1] and close < open) or (low < swingLow[1] and close > open)

// Distribution: Price extended from MAs in trend (smart money offloading)
bool isDistribution = (po3Uptrend and close > po3Fast * 1.005) or (not po3Uptrend and close < po3Fast * 0.995)

// Assign phase (priority: Manipulation > Accumulation > Distribution)
if isManipulation and inKillzone
    po3Phase := "MANIPULATION"
else if isAccumulation
    po3Phase := "ACCUMULATION"
else if isDistribution
    po3Phase := "DISTRIBUTION"
else
    po3Phase := "NEUTRAL"

// Phase change label
bool po3Changed = po3Phase != prevPO3Phase and po3Phase != "NEUTRAL"
prevPO3Phase := po3Phase

if po3Changed and showKillzones
    color po3Col = po3Phase == "ACCUMULATION" ? color.green : po3Phase == "MANIPULATION" ? color.orange : color.red
    label.new(bar_index, po3Phase == "DISTRIBUTION" ? high : low, "AMD: " + po3Phase, color=po3Col, textcolor=color.white, style=po3Phase == "DISTRIBUTION" ? label.style_label_down : label.style_label_up, size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ JUDAS SWING DETECTION â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Classic ICT fakeout: False breakout in opposite direction of true trend

// Detect false breakout + immediate reversal (within killzone for higher probability)
bool judasBearTrap = low < swingLow[1] and close > swingLow[1] and close > open and inKillzone  // Swept low, closed bullish
bool judasBullTrap = high > swingHigh[1] and close < swingHigh[1] and close < open and inKillzone  // Swept high, closed bearish

// Visual markers
plotshape(judasBullTrap, style=shape.xcross, location=location.abovebar, color=color.new(#FF00FF, 0), text="JUDAS â†“", textcolor=#FF00FF, size=size.small)
plotshape(judasBearTrap, style=shape.xcross, location=location.belowbar, color=color.new(#00FFFF, 0), text="JUDAS â†‘", textcolor=#00FFFF, size=size.small)

// Judas alerts
if judasBullTrap and not judasBullTrap[1]
    alert("âš ï¸ JUDAS SWING â†“ â€“ False bullish breakout! Potential bearish trap.", alert.freq_once_per_bar_close)

if judasBearTrap and not judasBearTrap[1]
    alert("âš ï¸ JUDAS SWING â†‘ â€“ False bearish breakout! Potential bullish trap.", alert.freq_once_per_bar_close)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ OTE ZONE (OPTIMAL TRADE ENTRY) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT's golden pocket: 0.62-0.79 Fibonacci retracement of recent swing

// OTE Settings (using existing showFVG toggle for simplicity, or add dedicated)
bool showOTE = showFVG  // Reuses FVG toggle for now

// Find recent significant swing (larger lookback for meaningful swings)
int oteLookback = structLen * 3
float oteSwingHigh = ta.highest(high, oteLookback)
float oteSwingLow = ta.lowest(low, oteLookback)
float oteRange = oteSwingHigh - oteSwingLow

// Calculate OTE levels (from swing high for bearish, from swing low for bullish)
// Bullish OTE: retracement down from swing high (buy zone)
float ote62Bull = oteSwingHigh - oteRange * 0.62
float ote705Bull = oteSwingHigh - oteRange * 0.705
float ote79Bull = oteSwingHigh - oteRange * 0.79

// Bearish OTE: retracement up from swing low (sell zone)
float ote62Bear = oteSwingLow + oteRange * 0.62
float ote705Bear = oteSwingLow + oteRange * 0.705
float ote79Bear = oteSwingLow + oteRange * 0.79

// Determine which OTE to show based on trend
bool showBullOTE = htfBullTrend and close < ote62Bull  // Price pulled back into bull OTE
bool showBearOTE = htfBearTrend and close > ote62Bear  // Price pulled back into bear OTE

// OTE Zone colors
color oteZoneCol = color.new(#9C27B0, 85)  // Purple for OTE
color oteMidCol = color.new(#E91E63, 80)   // Pink for 0.705 (sweet spot)

// Draw OTE zone as box (only when price is in zone)
var box oteBox = na
var line ote705Line = na
var label oteLabel = na

if showOTE and barstate.islast
    // Clean up old
    box.delete(oteBox)
    line.delete(ote705Line)
    label.delete(oteLabel)
    
    if showBullOTE
        // Draw bullish OTE zone (0.62-0.79 from swing high)
        oteBox := box.new(bar_index - 50, ote62Bull, bar_index + 10, ote79Bull, border_color=color.purple, bgcolor=oteZoneCol, border_width=1)
        ote705Line := line.new(bar_index - 50, ote705Bull, bar_index + 10, ote705Bull, color=oteMidCol, style=line.style_dashed, width=2)
        oteLabel := label.new(bar_index + 12, ote705Bull, "OTE ğŸ¯", color=color.purple, textcolor=color.white, style=label.style_label_left, size=size.small)
    
    else if showBearOTE
        // Draw bearish OTE zone (0.62-0.79 from swing low)
        oteBox := box.new(bar_index - 50, ote79Bear, bar_index + 10, ote62Bear, border_color=color.purple, bgcolor=oteZoneCol, border_width=1)
        ote705Line := line.new(bar_index - 50, ote705Bear, bar_index + 10, ote705Bear, color=oteMidCol, style=line.style_dashed, width=2)
        oteLabel := label.new(bar_index + 12, ote705Bear, "OTE ğŸ¯", color=color.purple, textcolor=color.white, style=label.style_label_left, size=size.small)

// Alert when price enters OTE zone
bool inBullOTE = close >= ote79Bull and close <= ote62Bull and htfBullTrend
bool inBearOTE = close >= ote62Bear and close <= ote79Bear and htfBearTrend

if inBullOTE and not inBullOTE[1] and inKillzone
    alert("ğŸ¯ BULLISH OTE ZONE â€“ Price in 0.62-0.79 retracement! Look for FVG/OB confluence.", alert.freq_once_per_bar_close)

if inBearOTE and not inBearOTE[1] and inKillzone
    alert("ğŸ¯ BEARISH OTE ZONE â€“ Price in 0.62-0.79 retracement! Look for FVG/OB confluence.", alert.freq_once_per_bar_close)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 8. DASHBOARD â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var table dash = table.new(position.top_right, 2, 9, bgcolor=color.new(color.black, 60), border_width=1, border_color=color.gray)

if showZodiac and barstate.islast
    table.cell(dash, 0, 0, "ICT x AEP ğŸ”¥", text_color=color.white, text_size=size.small, bgcolor=elemCol)
    table.merge_cells(dash, 0, 0, 1, 0)
    
    string sess = inNYPM ? "ğŸŸ£ NY PM" : inNYLunch ? "ğŸŸ  NY LUNCH" : inNY ? "ğŸŸ¢ NY AM" : inLondon ? "ğŸ”´ LONDON" : inAsia ? "ğŸ”µ ASIA" : "â¸ï¸ OFF"
    color sessCol = inNYPM ? nyPMCol : inNYLunch ? nyLunchCol : inNY ? nyCol : inLondon ? londonCol : inAsia ? asiaCol : color.gray
    table.cell(dash, 0, 1, "Session", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 1, sess, text_color=sessCol, text_size=size.tiny)
    
    table.cell(dash, 0, 2, "Moon", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 2, moonPhase, text_color=color.white, text_size=size.tiny)
    
    table.cell(dash, 0, 3, "Sign", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 3, currentZodiac, text_color=elemCol, text_size=size.tiny)
    
    table.cell(dash, 0, 4, "Element", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 4, element, text_color=elemCol, text_size=size.tiny)
    
    table.cell(dash, 0, 5, "Profile", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 5, ictBias, text_color=color.yellow, text_size=size.tiny)
    
    table.cell(dash, 0, 6, "Focus", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 6, ictFocus, text_color=color.lime, text_size=size.tiny)
    
    table.cell(dash, 0, 7, "PDH", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 7, str.tostring(pdh, format.mintick), text_color=color.red, text_size=size.tiny)
    
    table.cell(dash, 0, 8, "PDL", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 8, str.tostring(pdl, format.mintick), text_color=color.green, text_size=size.tiny)

// Expand dashboard for PO3 (separate table - positioned below main dash)
var table po3Dash = table.new(position.middle_right, 2, 1, bgcolor=color.new(color.black, 70), border_width=1)
if showZodiac and barstate.islast
    color po3DashCol = po3Phase == "ACCUMULATION" ? color.green : po3Phase == "MANIPULATION" ? color.orange : po3Phase == "DISTRIBUTION" ? color.red : color.gray
    table.cell(po3Dash, 0, 0, "AMD", text_color=color.white, text_size=size.tiny)
    table.cell(po3Dash, 1, 0, po3Phase, text_color=po3DashCol, text_size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ DYNAMIC POP-UP LABELS â€“ FADE ANIMATION â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Persistent label references
var label popupNuclearLong = na
var label popupNuclearShort = na
var label popupKZLong = na
var label popupKZShort = na
var label popupLiqGrab = na

// Fade settings
int fadeDuration = 12

// Session text for alerts
string sessText = inSilverBullet ? "Silver Bullet" : inNYPM ? "NY PM" : inNYLunch ? "NY Lunch" : inNY ? "NY AM" : inLondon ? "London" : inAsia ? "Asia" : "Off"

// â•â•â• NUCLEAR POPUP â•â•â•
if nuclearLong and not nuclearLong[1]
    if not na(popupNuclearLong)
        label.delete(popupNuclearLong)
    popupNuclearLong := label.new(bar_index, low, "ğŸ”¥ NUCLEAR LONG", color=color.new(#FFD700, 0), textcolor=color.black, style=label.style_label_up, size=size.large, yloc=yloc.belowbar)
    alert("ğŸ”¥ NUCLEAR LONG | Price: " + str.tostring(close, "#.##") + " | " + sessText, alert.freq_once_per_bar_close)

if nuclearShort and not nuclearShort[1]
    if not na(popupNuclearShort)
        label.delete(popupNuclearShort)
    popupNuclearShort := label.new(bar_index, high, "ğŸ”¥ NUCLEAR SHORT", color=color.new(#FF4500, 0), textcolor=color.white, style=label.style_label_down, size=size.large, yloc=yloc.abovebar)
    alert("ğŸ”¥ NUCLEAR SHORT | Price: " + str.tostring(close, "#.##") + " | " + sessText, alert.freq_once_per_bar_close)

// â•â•â• KZ POPUP (smaller, only when not nuclear) â•â•â•
if kzLong and not kzLong[1] and not nuclearLong
    if not na(popupKZLong)
        label.delete(popupKZLong)
    popupKZLong := label.new(bar_index, low, "KZ LONG âš¡", color=color.green, textcolor=color.white, style=label.style_label_up, size=size.normal, yloc=yloc.belowbar)

if kzShort and not kzShort[1] and not nuclearShort
    if not na(popupKZShort)
        label.delete(popupKZShort)
    popupKZShort := label.new(bar_index, high, "KZ SHORT âš¡", color=color.red, textcolor=color.white, style=label.style_label_down, size=size.normal, yloc=yloc.abovebar)

// â•â•â• LIQUIDITY GRAB POPUP â•â•â•
if (pdhSweep or pdlSweep) and inKillzone
    if not na(popupLiqGrab)
        label.delete(popupLiqGrab)
    string liqText = pdhSweep ? "ğŸ’§ PDH SWEPT" : "ğŸ’§ PDL SWEPT"
    color liqCol = pdhSweep ? color.red : color.green
    popupLiqGrab := label.new(bar_index, pdhSweep ? high : low, liqText, color=liqCol, textcolor=color.white, style=pdhSweep ? label.style_label_down : label.style_label_up, size=size.normal, yloc=pdhSweep ? yloc.abovebar : yloc.belowbar)

// â•â•â• FADE ANIMATION (simplified - delete after duration) â•â•â•
fadePopup(lbl, duration) =>
    if not na(lbl)
        int age = bar_index - label.get_x(lbl)
        if age > duration
            label.delete(lbl)
            label(na)
        else
            lbl
    else
        lbl

popupNuclearLong := fadePopup(popupNuclearLong, fadeDuration)
popupNuclearShort := fadePopup(popupNuclearShort, fadeDuration)
popupKZLong := fadePopup(popupKZLong, 8)
popupKZShort := fadePopup(popupKZShort, 8)
popupLiqGrab := fadePopup(popupLiqGrab, 6)

// â•â•â• LIQUIDITY GRAB LABELS (plotshape after inKillzone defined) â•â•â•
plotshape(pdhSweep and inKillzone, style=shape.labeldown, location=location.abovebar, color=color.new(color.red, 20), text="LIQ GRAB â†“", textcolor=color.white, size=size.tiny)
plotshape(pdlSweep and inKillzone, style=shape.labelup, location=location.belowbar, color=color.new(color.green, 20), text="LIQ GRAB â†‘", textcolor=color.white, size=size.tiny)

// â•â•â• BACKGROUND PULSE ON NUCLEAR (3-bar countdown) â•â•â•
var int nuclearFlashAge = 0
if nuclearLong and not nuclearLong[1]
    nuclearFlashAge := 3
if nuclearShort and not nuclearShort[1]
    nuclearFlashAge := 3

color pulseBg = na
if nuclearFlashAge > 0
    float flashOpacity = nuclearFlashAge % 2 == 0 ? 70 : 88  // alternating pulse
    pulseBg := nuclearLong ? color.new(#FFD700, flashOpacity) : color.new(#FF4500, flashOpacity)
    nuclearFlashAge -= 1
bgcolor(pulseBg, title="Nuclear Pulse")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ ALERTS (Enhanced AI-Style) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(kzLong, title="Killzone LONG", message="ğŸ¯ Killzone LONG")
alertcondition(kzShort, title="Killzone SHORT", message="ğŸ¯ Killzone SHORT")
alertcondition(nuclearLong, title="ğŸ”¥ NUCLEAR LONG", message="ğŸ”¥ NUCLEAR LONG â€“ High-confluence entry!")
alertcondition(nuclearShort, title="ğŸ”¥ NUCLEAR SHORT", message="ğŸ”¥ NUCLEAR SHORT â€“ High-confluence entry!")
alertcondition(bosUp, title="Bullish BOS", message="BOS UP")
alertcondition(bosDn, title="Bearish BOS", message="BOS DOWN")
alertcondition(londonSessionStart, title="London Open", message="London Session Started")
alertcondition(nySessionStart, title="NY Open", message="NY AM Session Started")
alertcondition(sbSessionStart, title="Silver Bullet", message="â° Silver Bullet Window Open (10:00-11:00 NY)")
alertcondition(pdhSweep and inKillzone, title="PDH Liquidity Sweep", message="ğŸ’§ PDH Swept - Potential Reversal")
alertcondition(pdlSweep and inKillzone, title="PDL Liquidity Sweep", message="ğŸ’§ PDL Swept - Potential Reversal")
alertcondition(conflictLong or conflictShort, title="âš  AEP vs ICT Conflict", message="âš  Signal Conflict - AEP and ICT disagree!")
alertcondition(judasBullTrap, title="âš ï¸ JUDAS â†“", message="âš ï¸ JUDAS SWING â†“ â€“ False bullish breakout! Bearish trap.")
alertcondition(judasBearTrap, title="âš ï¸ JUDAS â†‘", message="âš ï¸ JUDAS SWING â†‘ â€“ False bearish breakout! Bullish trap.")
alertcondition(po3Phase == "MANIPULATION", title="ğŸ­ AMD Manipulation", message="ğŸ­ Manipulation phase detected â€“ Watch for Judas swing!")
alertcondition(inBullOTE and inKillzone, title="ğŸ¯ Bullish OTE", message="ğŸ¯ Price in BULLISH OTE zone (0.62-0.79) â€“ Look for long entry!")
alertcondition(inBearOTE and inKillzone, title="ğŸ¯ Bearish OTE", message="ğŸ¯ Price in BEARISH OTE zone (0.62-0.79) â€“ Look for short entry!")




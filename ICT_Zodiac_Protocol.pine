// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0
// Â© ICT x AEP Protocol [NUCLEAR] - Confluence Trading System

//@version=5
indicator("ICT x AEP [NUCLEAR]", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ MASTER TOGGLES â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpMaster = "Master Toggles"
bool showKillzones = input.bool(true, "Show Killzones", group=grpMaster)
bool showPivots = input.bool(true, "Show Pivots", group=grpMaster)
bool showPDLevels = input.bool(true, "Show PDH/PDL/PWH/PWL", group=grpMaster)
bool showFVG = input.bool(true, "Show FVGs", group=grpMaster)
bool showOB = input.bool(true, "Show Order Blocks", group=grpMaster)
bool showBOS = input.bool(true, "Show Break of Structure", group=grpMaster)
bool showZodiac = input.bool(true, "Show Zodiac Dashboard", group=grpMaster)
bool presentMode = input.bool(true, "Present Mode (Fresh Zones Only)", group=grpMaster, tooltip="When ON, removes FVGs/OBs when price fills them")
bool zodiacFilter = input.bool(true, "Zodiac Signal Filter", group=grpMaster, tooltip="Only show signals when zodiac aligns with direction")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ CONFLUENCE SETTINGS (AEP + ICT) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpConfl = "ðŸ”¥ Confluence (AEP + ICT)"
bool enableConfluence = input.bool(true, "Enable Confluence Detection", group=grpConfl)
int fastLen = input.int(9, "Fast MA Length", minval=1, group=grpConfl)
int slowLen = input.int(21, "Slow MA Length", minval=1, group=grpConfl)
int rsiLen = input.int(14, "RSI Length", minval=1, group=grpConfl)
float rsiOB = input.float(70, "RSI Overbought", group=grpConfl)
float rsiOS = input.float(30, "RSI Oversold", group=grpConfl)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ KILLZONE SETTINGS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpKZ = "Killzones"
bool showKZBoxes = input.bool(true, "Show Killzone Boxes", group=grpKZ)
bool showKZText = input.bool(true, "Display Text", inline="kzdisp", group=grpKZ)
bool showKZOpen = input.bool(true, "Show KZ Open Lines", group=grpKZ)
int kzTransparency = input.int(70, "Box Transparency", minval=0, maxval=100, group=grpKZ)

grpAsia = "Asia"
bool showAsiaKZ = input.bool(true, "", inline="asia", group=grpAsia)
string asiaStart = input.string("20:00", "Start", inline="asia", group=grpAsia)
string asiaEnd = input.string("00:00", "End", inline="asia", group=grpAsia)
color asiaCol = input.color(color.blue, "", inline="asia", group=grpAsia)

grpLondon = "London"
bool showLondonKZ = input.bool(true, "", inline="ldn", group=grpLondon)
string londonStart = input.string("02:00", "Start", inline="ldn", group=grpLondon)
string londonEnd = input.string("05:00", "End", inline="ldn", group=grpLondon)
color londonCol = input.color(color.red, "", inline="ldn", group=grpLondon)

grpNYAM = "NY AM"
bool showNYKZ = input.bool(true, "", inline="nyam", group=grpNYAM)
string nyStart = input.string("09:30", "Start", inline="nyam", group=grpNYAM)
string nyEnd = input.string("11:00", "End", inline="nyam", group=grpNYAM)
color nyCol = input.color(color.teal, "", inline="nyam", group=grpNYAM)

grpNYLunch = "NY Lunch"
bool showNYLunch = input.bool(true, "", inline="nylunch", group=grpNYLunch)
string nyLunchStart = input.string("12:00", "Start", inline="nylunch", group=grpNYLunch)
string nyLunchEnd = input.string("13:00", "End", inline="nylunch", group=grpNYLunch)
color nyLunchCol = input.color(color.orange, "", inline="nylunch", group=grpNYLunch)

grpNYPM = "NY PM"
bool showNYPM = input.bool(true, "", inline="nypm", group=grpNYPM)
string nyPMStart = input.string("13:30", "Start", inline="nypm", group=grpNYPM)
string nyPMEnd = input.string("16:00", "End", inline="nypm", group=grpNYPM)
color nyPMCol = input.color(color.purple, "", inline="nypm", group=grpNYPM)

grpSilverBullet = "Silver Bullet (10-11 AM)"
bool showSilverBullet = input.bool(true, "", inline="sb", group=grpSilverBullet, tooltip="ICT's high-probability 10:00-11:00 AM NY window")
string sbStart = input.string("10:00", "Start", inline="sb", group=grpSilverBullet)
string sbEnd = input.string("11:00", "End", inline="sb", group=grpSilverBullet)
color sbCol = input.color(color.lime, "", inline="sb", group=grpSilverBullet)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ PIVOT SETTINGS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpPivot = "Pivots"
bool showDailyPivots = input.bool(true, "Daily Pivots", group=grpPivot)
bool showWeeklyPivots = input.bool(false, "Weekly Pivots", group=grpPivot)
string pivotType = input.string("Traditional", "Type", options=["Traditional", "Fibonacci", "Camarilla"], group=grpPivot)
color pivotCol = input.color(color.orange, "Pivot (P)", group=grpPivot)
color rCol = input.color(color.red, "R Levels", group=grpPivot)
color sCol = input.color(color.green, "S Levels", group=grpPivot)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ ICT STRUCTURE SETTINGS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpICT = "ICT Structure"
int structLen = input.int(5, "Structure Lookback", minval=3, group=grpICT)
int maxFVG = input.int(3, "Max FVGs", minval=1, maxval=20, group=grpICT)
int maxOB = input.int(3, "Max Order Blocks", minval=1, maxval=10, group=grpICT)
color bullFvgCol = input.color(color.new(#089981, 85), "Bull FVG", group=grpICT)
color bearFvgCol = input.color(color.new(#f23645, 85), "Bear FVG", group=grpICT)
color bullObCol = input.color(color.new(#00bcd4, 80), "Bull OB", group=grpICT)
color bearObCol = input.color(color.new(#ff5252, 80), "Bear OB", group=grpICT)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ ORDER BLOCK SCORING â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpOBScore = "OB Scoring"
int obScoreThreshold = input.int(5, "Min OB Score (0-10)", minval=0, maxval=10, group=grpOBScore, tooltip="Only show OBs scoring above this")
float obATRMult = input.float(2.0, "Displacement ATR Mult", minval=1.0, step=0.5, group=grpOBScore, tooltip="Move away must exceed this * ATR")
bool showOBScore = input.bool(true, "Show OB Score", group=grpOBScore)
bool hideWeakOBs = input.bool(false, "Hide Weak OBs", group=grpOBScore, tooltip="Hide OBs below threshold instead of graying out")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ FVG SCORING â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpFVGScore = "FVG Scoring"
int fvgScoreThreshold = input.int(5, "Min FVG Score (0-10)", minval=0, maxval=10, group=grpFVGScore, tooltip="Only show FVGs scoring above this")
float fvgATRMult = input.float(2.0, "Displacement ATR Mult", minval=1.0, step=0.5, group=grpFVGScore)
bool showFVGScore = input.bool(true, "Show FVG Score", group=grpFVGScore)
bool hideWeakFVGs = input.bool(false, "Hide Weak FVGs", group=grpFVGScore)
bool detectIFVG = input.bool(true, "Detect Inverse FVGs (iFVG)", group=grpFVGScore, tooltip="Mark FVGs that get breached as inverse")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ ZODIAC SETTINGS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpAstro = "Zodiac"
int moonOffset = input.int(10, "Moon Degree Offset", group=grpAstro)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 1. ZODIAC CALCULATION â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
lunarAge() =>
    int y = year
    int m = month
    int d = dayofmonth
    if m <= 2
        y := y - 1
        m := m + 12
    int A = math.floor(y / 100)
    int B = 2 - A + math.floor(A / 4)
    float JD = math.floor(365.25 * (y + 4716)) + math.floor(30.6001 * (m + 1)) + d + B - 1524.5
    float age = (JD - 2451550.1 + moonOffset) % 29.53058867
    if age < 0
        age := age + 29.53058867
    age

float moonAge = lunarAge()
string[] zodiacSigns = array.from("Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo", "Libra", "Scorpio", "Sagittarius", "Capricorn", "Aquarius", "Pisces")
int zodiacIdx = math.floor((moonAge / 29.53) * 12) % 12
string currentZodiac = array.get(zodiacSigns, zodiacIdx)

string moonPhase = moonAge < 1.85 ? "ðŸŒ‘ New" : moonAge < 7.38 ? "ðŸŒ’ Wax Cres" : moonAge < 11.07 ? "ðŸŒ“ 1st Qtr" : moonAge < 14.76 ? "ðŸŒ” Wax Gib" : moonAge < 16.61 ? "ðŸŒ• Full" : moonAge < 22.14 ? "ðŸŒ– Wan Gib" : moonAge < 25.83 ? "ðŸŒ— 3rd Qtr" : "ðŸŒ˜ Wan Cres"

string element = "Neutral"
string ictBias = "Balanced"
string ictFocus = "Standard"
color elemCol = color.gray

string[] fireSigns = array.from("Aries", "Leo", "Sagittarius")
string[] earthSigns = array.from("Taurus", "Virgo", "Capricorn")
string[] airSigns = array.from("Gemini", "Libra", "Aquarius")
string[] waterSigns = array.from("Cancer", "Scorpio", "Pisces")

if array.includes(fireSigns, currentZodiac)
    element := "ðŸ”¥ FIRE"
    ictBias := "EXPANSION"
    ictFocus := "Trust BOS & FVGs"
    elemCol := color.orange
else if array.includes(waterSigns, currentZodiac)
    element := "ðŸ’§ WATER"
    ictBias := "MANIPULATION"
    ictFocus := "Fade Liq Grabs"
    elemCol := color.aqua
else if array.includes(airSigns, currentZodiac)
    element := "ðŸŒªï¸ AIR"
    ictBias := "CONSOLIDATION"
    ictFocus := "Scalp IRL"
    elemCol := color.silver
else if array.includes(earthSigns, currentZodiac)
    element := "ðŸŒ EARTH"
    ictBias := "STRUCTURE"
    ictFocus := "Deep OTE"
    elemCol := color.green

// Zodiac Bias for filtering
bool bullishBias = array.includes(fireSigns, currentZodiac) or array.includes(earthSigns, currentZodiac)
bool bearishBias = array.includes(waterSigns, currentZodiac) or array.includes(airSigns, currentZodiac)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 2. KILLZONE DETECTION â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Helper function to convert time strings to session format
asiaTimeStr = str.replace(asiaStart, ":", "") + "-" + str.replace(asiaEnd, ":", "")
londonTimeStr = str.replace(londonStart, ":", "") + "-" + str.replace(londonEnd, ":", "")
nyTimeStr = str.replace(nyStart, ":", "") + "-" + str.replace(nyEnd, ":", "")
nyLunchTimeStr = str.replace(nyLunchStart, ":", "") + "-" + str.replace(nyLunchEnd, ":", "")
nyPMTimeStr = str.replace(nyPMStart, ":", "") + "-" + str.replace(nyPMEnd, ":", "")
sbTimeStr = str.replace(sbStart, ":", "") + "-" + str.replace(sbEnd, ":", "")

bool inAsia = not na(time(timeframe.period, asiaTimeStr, "America/New_York"))
bool inLondon = not na(time(timeframe.period, londonTimeStr, "America/New_York"))
bool inNY = not na(time(timeframe.period, nyTimeStr, "America/New_York"))
bool inNYLunch = not na(time(timeframe.period, nyLunchTimeStr, "America/New_York"))
bool inNYPM = not na(time(timeframe.period, nyPMTimeStr, "America/New_York"))
bool inSilverBullet = not na(time(timeframe.period, sbTimeStr, "America/New_York"))

bool asiaSessionStart = inAsia and not inAsia[1]
bool londonSessionStart = inLondon and not inLondon[1]
bool nySessionStart = inNY and not inNY[1]
bool nyLunchSessionStart = inNYLunch and not inNYLunch[1]
bool nyPMSessionStart = inNYPM and not inNYPM[1]
bool sbSessionStart = inSilverBullet and not inSilverBullet[1]

// Session tracking
var float asiaOpen = na, var float londonOpen = na, var float nyOpen = na, var float nyLunchOpen = na, var float nyPMOpen = na, var float sbOpen = na
var float asiaHigh = na, var float asiaLow = na
var float londonHigh = na, var float londonLow = na
var float nyHigh = na, var float nyLow = na
var float nyLunchHigh = na, var float nyLunchLow = na
var float nyPMHigh = na, var float nyPMLow = na
var float sbHigh = na, var float sbLow = na
var int asiaStartBar = na, var int londonStartBar = na, var int nyStartBar = na, var int nyLunchStartBar = na, var int nyPMStartBar = na, var int sbStartBar = na

// Asia
if asiaSessionStart
    asiaOpen := open, asiaHigh := high, asiaLow := low, asiaStartBar := bar_index
if inAsia
    asiaHigh := math.max(asiaHigh, high), asiaLow := math.min(asiaLow, low)

// London  
if londonSessionStart
    londonOpen := open, londonHigh := high, londonLow := low, londonStartBar := bar_index
if inLondon
    londonHigh := math.max(londonHigh, high), londonLow := math.min(londonLow, low)

// NY AM
if nySessionStart
    nyOpen := open, nyHigh := high, nyLow := low, nyStartBar := bar_index
if inNY
    nyHigh := math.max(nyHigh, high), nyLow := math.min(nyLow, low)

// NY Lunch
if nyLunchSessionStart
    nyLunchOpen := open, nyLunchHigh := high, nyLunchLow := low, nyLunchStartBar := bar_index
if inNYLunch
    nyLunchHigh := math.max(nyLunchHigh, high), nyLunchLow := math.min(nyLunchLow, low)

// NY PM
if nyPMSessionStart
    nyPMOpen := open, nyPMHigh := high, nyPMLow := low, nyPMStartBar := bar_index
if inNYPM
    nyPMHigh := math.max(nyPMHigh, high), nyPMLow := math.min(nyPMLow, low)

// â•â•â• KILLZONE BOXES â•â•â•
var box asiaBox = na, var box londonBox = na, var box nyBox = na, var box nyLunchBox = na, var box nyPMBox = na
var line asiaHighLine = na, var line asiaLowLine = na
var line londonHighLine = na, var line londonLowLine = na
var line nyHighLine = na, var line nyLowLine = na
var line nyLunchHighLine = na, var line nyLunchLowLine = na
var line nyPMHighLine = na, var line nyPMLowLine = na
var label asiaLabel = na, var label londonLabel = na, var label nyLabel = na, var label nyLunchLabel = na, var label nyPMLabel = na

// Update boxes dynamically during session
if showKillzones and showKZBoxes and showAsiaKZ and inAsia
    box.delete(asiaBox)
    label.delete(asiaLabel)
    asiaBox := box.new(asiaStartBar, asiaHigh, bar_index, asiaLow, border_color=asiaCol, bgcolor=color.new(asiaCol, kzTransparency), border_width=1)
    if showKZText
        asiaLabel := label.new(asiaStartBar, asiaHigh, "ASIA", style=label.style_none, textcolor=asiaCol, size=size.small)

if showKillzones and showKZBoxes and showLondonKZ and inLondon
    box.delete(londonBox)
    label.delete(londonLabel)
    londonBox := box.new(londonStartBar, londonHigh, bar_index, londonLow, border_color=londonCol, bgcolor=color.new(londonCol, kzTransparency), border_width=1)
    if showKZText
        londonLabel := label.new(londonStartBar, londonHigh, "LONDON", style=label.style_none, textcolor=londonCol, size=size.small)

if showKillzones and showKZBoxes and showNYKZ and inNY
    box.delete(nyBox)
    label.delete(nyLabel)
    nyBox := box.new(nyStartBar, nyHigh, bar_index, nyLow, border_color=nyCol, bgcolor=color.new(nyCol, kzTransparency), border_width=1)
    if showKZText
        nyLabel := label.new(nyStartBar, nyHigh, "NY AM", style=label.style_none, textcolor=nyCol, size=size.small)

if showKillzones and showKZBoxes and showNYLunch and inNYLunch
    box.delete(nyLunchBox)
    label.delete(nyLunchLabel)
    nyLunchBox := box.new(nyLunchStartBar, nyLunchHigh, bar_index, nyLunchLow, border_color=nyLunchCol, bgcolor=color.new(nyLunchCol, kzTransparency), border_width=1)
    if showKZText
        nyLunchLabel := label.new(nyLunchStartBar, nyLunchHigh, "NY LUNCH", style=label.style_none, textcolor=nyLunchCol, size=size.small)

if showKillzones and showKZBoxes and showNYPM and inNYPM
    box.delete(nyPMBox)
    label.delete(nyPMLabel)
    nyPMBox := box.new(nyPMStartBar, nyPMHigh, bar_index, nyPMLow, border_color=nyPMCol, bgcolor=color.new(nyPMCol, kzTransparency), border_width=1)
    if showKZText
        nyPMLabel := label.new(nyPMStartBar, nyPMHigh, "NY PM", style=label.style_none, textcolor=nyPMCol, size=size.small)

// KZ Open lines (dotted through session)
plot(showKZOpen and showAsiaKZ and inAsia ? asiaOpen : na, "Asia Open", asiaCol, style=plot.style_linebr)
plot(showKZOpen and showLondonKZ and inLondon ? londonOpen : na, "LDN Open", londonCol, style=plot.style_linebr)
plot(showKZOpen and showNYKZ and inNY ? nyOpen : na, "NY Open", nyCol, style=plot.style_linebr)
plot(showKZOpen and showNYLunch and inNYLunch ? nyLunchOpen : na, "NY Lunch Open", nyLunchCol, style=plot.style_linebr)
plot(showKZOpen and showNYPM and inNYPM ? nyPMOpen : na, "NY PM Open", nyPMCol, style=plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 3. PIVOTS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[dHigh, dLow, dClose] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)

calcPivots(h, l, c, pType) =>
    float p = (h + l + c) / 3
    float r1 = 0.0, float r2 = 0.0, float s1 = 0.0, float s2 = 0.0
    if pType == "Traditional"
        r1 := (2 * p) - l, s1 := (2 * p) - h
        r2 := p + (h - l), s2 := p - (h - l)
    else if pType == "Fibonacci"
        r1 := p + 0.382 * (h - l), s1 := p - 0.382 * (h - l)
        r2 := p + 0.618 * (h - l), s2 := p - 0.618 * (h - l)
    else if pType == "Camarilla"
        r1 := c + (h - l) * 1.1 / 12, s1 := c - (h - l) * 1.1 / 12
        r2 := c + (h - l) * 1.1 / 6, s2 := c - (h - l) * 1.1 / 6
    [p, r1, r2, s1, s2]

[dP, dR1, dR2, dS1, dS2] = calcPivots(dHigh, dLow, dClose, pivotType)

plot(showPivots and showDailyPivots ? dP : na, "Pivot", pivotCol, style=plot.style_circles, linewidth=2)
plot(showPivots and showDailyPivots ? dR1 : na, "R1", rCol, style=plot.style_cross)
plot(showPivots and showDailyPivots ? dR2 : na, "R2", color.new(rCol, 40), style=plot.style_cross)
plot(showPivots and showDailyPivots ? dS1 : na, "S1", sCol, style=plot.style_cross)
plot(showPivots and showDailyPivots ? dS2 : na, "S2", color.new(sCol, 40), style=plot.style_cross)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 4. PDH/PDL/PWH/PWL â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float pdh = request.security(syminfo.tickerid, "D", high[1], lookahead=barmerge.lookahead_on)
float pdl = request.security(syminfo.tickerid, "D", low[1], lookahead=barmerge.lookahead_on)
float pwh = request.security(syminfo.tickerid, "W", high[1], lookahead=barmerge.lookahead_on)
float pwl = request.security(syminfo.tickerid, "W", low[1], lookahead=barmerge.lookahead_on)

// Horizontal lines for PDH/PDL/PWH/PWL
var line pdhLine = na, var line pdlLine = na, var line pwhLine = na, var line pwlLine = na
var label pdhLabel = na, var label pdlLabel = na, var label pwhLabel = na, var label pwlLabel = na

if showPDLevels and barstate.islast
    // Delete old lines
    line.delete(pdhLine), line.delete(pdlLine), line.delete(pwhLine), line.delete(pwlLine)
    label.delete(pdhLabel), label.delete(pdlLabel), label.delete(pwhLabel), label.delete(pwlLabel)
    
    // PDH/PDL
    pdhLine := line.new(bar_index - 100, pdh, bar_index + 20, pdh, color=color.red, style=line.style_solid, width=2)
    pdlLine := line.new(bar_index - 100, pdl, bar_index + 20, pdl, color=color.green, style=line.style_solid, width=2)
    pdhLabel := label.new(bar_index + 22, pdh, "PDH", style=label.style_none, textcolor=color.red, size=size.small)
    pdlLabel := label.new(bar_index + 22, pdl, "PDL", style=label.style_none, textcolor=color.green, size=size.small)
    
    // PWH/PWL
    pwhLine := line.new(bar_index - 100, pwh, bar_index + 20, pwh, color=color.fuchsia, style=line.style_dashed, width=1)
    pwlLine := line.new(bar_index - 100, pwl, bar_index + 20, pwl, color=color.aqua, style=line.style_dashed, width=1)
    pwhLabel := label.new(bar_index + 22, pwh, "PWH", style=label.style_none, textcolor=color.fuchsia, size=size.small)
    pwlLabel := label.new(bar_index + 22, pwl, "PWL", style=label.style_none, textcolor=color.aqua, size=size.small)

// â•â•â• LIQUIDITY SWEEP DETECTION â•â•â•
// Wick beyond PDH/PDL but close back inside = liquidity grab
bool pdhSweep = high > pdh and close < pdh  // Swept PDH, closed below
bool pdlSweep = low < pdl and close > pdl   // Swept PDL, closed above
bool pwhSweep = high > pwh and close < pwh  // Swept PWH
bool pwlSweep = low < pwl and close > pwl   // Swept PWL

// Liquidity grab labels
plotshape(pdhSweep and inKillzone, style=shape.labeldown, location=location.abovebar, color=color.new(color.red, 20), text="LIQ GRAB â†“", textcolor=color.white, size=size.tiny)
plotshape(pdlSweep and inKillzone, style=shape.labelup, location=location.belowbar, color=color.new(color.green, 20), text="LIQ GRAB â†‘", textcolor=color.white, size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 5. FVG DETECTION (INTELLIGENT SCORING + iFVG) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool isBullFVG = low > high[2]
bool isBearFVG = high < low[2]

// Strength Detection
float avgRange = ta.sma(high - low, 14)
float fvgGapBull = isBullFVG ? (low - high[2]) : 0
float fvgGapBear = isBearFVG ? (low[2] - high) : 0
float dispBody = math.abs(close[1] - open[1])
float avgBody = ta.sma(math.abs(close - open), 14)
float fvgATR = ta.atr(14)

// Killzone check (includes Silver Bullet)
bool inKillzone = inAsia or inLondon or inNY or inNYLunch or inNYPM or inSilverBullet
bool hasDisplacement = dispBody > avgBody * 1.5

// HTF Trend for FVG alignment (reuse from later if available, or calculate here)
float fvgFastEMA = ta.ema(close, 9)
float fvgSlowEMA = ta.ema(close, 21)
bool fvgHtfBullTrend = fvgFastEMA > fvgSlowEMA
bool fvgHtfBearTrend = fvgFastEMA < fvgSlowEMA

// FVG Scoring Function (0-10)
calcFVGScore(gapSize, displacement, inKZ, htfAligned, isLargeGap) =>
    int score = 0
    // +3 Strong displacement (middle candle > 2x ATR)
    if displacement > fvgATR * fvgATRMult
        score += 3
    // +2 Unmitigated (all new FVGs are unmitigated)
    score += 2
    // +2 HTF trend aligned
    if htfAligned
        score += 2
    // +1 In killzone
    if inKZ
        score += 1
    // +1 Large gap size
    if isLargeGap
        score += 1
    // +1 Strong body displacement
    if displacement > avgBody * 1.5
        score += 1
    math.min(score, 10)

// FVG Color by Score
fvgColorByScore(score, isBull) =>
    if score >= 8
        isBull ? color.new(#00ff88, 60) : color.new(#ff4444, 60)  // Bright
    else if score >= 5
        isBull ? color.new(#089981, 70) : color.new(#f23645, 70)  // Normal
    else
        color.new(color.gray, 80)  // Weak

// FVG Tracking Arrays
var box[] bullFVGs = array.new_box()
var box[] bearFVGs = array.new_box()
var float[] bullFVGTops = array.new_float()
var float[] bullFVGBots = array.new_float()
var float[] bearFVGTops = array.new_float()
var float[] bearFVGBots = array.new_float()
var int[] bullFVGScores = array.new_int()
var int[] bearFVGScores = array.new_int()

// iFVG Tracking
var box[] iFVGs = array.new_box()

// Create Bull FVG with Scoring
if showFVG and isBullFVG
    float fvgTop = low
    float fvgBot = high[2]
    bool isLargeGap = fvgGapBull > avgRange * 0.3
    int fvgScore = calcFVGScore(fvgGapBull, dispBody, inKillzone, fvgHtfBullTrend, isLargeGap)
    
    // Apply threshold filter
    if fvgScore >= fvgScoreThreshold or not hideWeakFVGs
        string fvgLabel = showFVGScore ? "â–® FVG " + str.tostring(fvgScore) + "/10" : "â–® FVG"
        if fvgScore >= 8
            fvgLabel := fvgLabel + " â˜…"
        int bWidth = fvgScore >= 8 ? 3 : fvgScore >= 5 ? 2 : 1
        color bCol = fvgColorByScore(fvgScore, true)
        color borderCol = fvgScore >= 5 ? color.new(#089981, 30) : color.new(color.gray, 40)
        
        box b = box.new(bar_index[2], fvgTop, bar_index + 50, fvgBot, border_color=borderCol, bgcolor=bCol, border_width=bWidth, text=fvgLabel, text_color=#089981, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
        array.push(bullFVGs, b)
        array.push(bullFVGTops, fvgTop)
        array.push(bullFVGBots, fvgBot)
        array.push(bullFVGScores, fvgScore)
        if array.size(bullFVGs) > maxFVG
            box.delete(array.shift(bullFVGs))
            array.shift(bullFVGTops)
            array.shift(bullFVGBots)
            array.shift(bullFVGScores)

// Create Bear FVG with Scoring
if showFVG and isBearFVG
    float fvgTop = low[2]
    float fvgBot = high
    bool isLargeGap = fvgGapBear > avgRange * 0.3
    int fvgScore = calcFVGScore(fvgGapBear, dispBody, inKillzone, fvgHtfBearTrend, isLargeGap)
    
    // Apply threshold filter
    if fvgScore >= fvgScoreThreshold or not hideWeakFVGs
        string fvgLabel = showFVGScore ? "â–® FVG " + str.tostring(fvgScore) + "/10" : "â–® FVG"
        if fvgScore >= 8
            fvgLabel := fvgLabel + " â˜…"
        int bWidth = fvgScore >= 8 ? 3 : fvgScore >= 5 ? 2 : 1
        color bCol = fvgColorByScore(fvgScore, false)
        color borderCol = fvgScore >= 5 ? color.new(#f23645, 30) : color.new(color.gray, 40)
        
        box b = box.new(bar_index[2], fvgTop, bar_index + 50, fvgBot, border_color=borderCol, bgcolor=bCol, border_width=bWidth, text=fvgLabel, text_color=#f23645, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
        array.push(bearFVGs, b)
        array.push(bearFVGTops, fvgTop)
        array.push(bearFVGBots, fvgBot)
        array.push(bearFVGScores, fvgScore)
        if array.size(bearFVGs) > maxFVG
            box.delete(array.shift(bearFVGs))
            array.shift(bearFVGTops)
            array.shift(bearFVGBots)
            array.shift(bearFVGScores)

// â•â•â• FVG MITIGATION + iFVG DETECTION â•â•â•
if presentMode and array.size(bullFVGs) > 0
    for i = array.size(bullFVGs) - 1 to 0
        if i < array.size(bullFVGBots)
            float bot = array.get(bullFVGBots, i)
            float top = array.get(bullFVGTops, i)
            // Bull FVG breached completely = create iFVG (bearish)
            if close < bot
                if detectIFVG
                    // Create iFVG (inverse - now bearish resistance)
                    box iFvg = box.new(bar_index - 5, top, bar_index + 30, bot, border_color=color.new(color.orange, 20), bgcolor=color.new(color.orange, 80), border_width=2, text="iFVG â†“", text_color=color.orange, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
                    array.push(iFVGs, iFvg)
                    if array.size(iFVGs) > maxFVG
                        box.delete(array.shift(iFVGs))
                // Remove original
                box.delete(array.get(bullFVGs, i))
                array.remove(bullFVGs, i)
                array.remove(bullFVGTops, i)
                array.remove(bullFVGBots, i)
                if i < array.size(bullFVGScores)
                    array.remove(bullFVGScores, i)

if presentMode and array.size(bearFVGs) > 0
    for i = array.size(bearFVGs) - 1 to 0
        if i < array.size(bearFVGTops)
            float top = array.get(bearFVGTops, i)
            float bot = array.get(bearFVGBots, i)
            // Bear FVG breached completely = create iFVG (bullish)
            if close > top
                if detectIFVG
                    // Create iFVG (inverse - now bullish support)
                    box iFvg = box.new(bar_index - 5, top, bar_index + 30, bot, border_color=color.new(color.orange, 20), bgcolor=color.new(color.orange, 80), border_width=2, text="iFVG â†‘", text_color=color.orange, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
                    array.push(iFVGs, iFvg)
                    if array.size(iFVGs) > maxFVG
                        box.delete(array.shift(iFVGs))
                // Remove original
                box.delete(array.get(bearFVGs, i))
                array.remove(bearFVGs, i)
                array.remove(bearFVGTops, i)
                array.remove(bearFVGBots, i)
                if i < array.size(bearFVGScores)
                    array.remove(bearFVGScores, i)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 6. ORDER BLOCKS (INTELLIGENT SCORING) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float sh = ta.pivothigh(high, structLen, structLen)
float sl = ta.pivotlow(low, structLen, structLen)
var float lastSH = na, var float lastSL = na
if not na(sh)
    lastSH := sh
if not na(sl)
    lastSL := sl

bool crossHigh = ta.crossover(close, lastSH)
bool crossLow = ta.crossunder(close, lastSL)
bool bosUp = not na(lastSH) and crossHigh
bool bosDn = not na(lastSL) and crossLow

if showBOS and bosUp
    label.new(bar_index, high, "BOSâ†‘", color=color.new(color.green, 100), style=label.style_label_down, textcolor=color.lime, size=size.tiny)
if showBOS and bosDn
    label.new(bar_index, low, "BOSâ†“", color=color.new(color.red, 100), style=label.style_label_up, textcolor=color.red, size=size.tiny)

// OB Tracking Arrays
var box[] bullOBs = array.new_box()
var box[] bearOBs = array.new_box()
var float[] bullOBBots = array.new_float()
var float[] bearOBTops = array.new_float()
var int[] bullOBScores = array.new_int()
var int[] bearOBScores = array.new_int()

// ATR & Body for scoring (avgBody reused from line 349)
float atrVal = ta.atr(14)
float bodySize = math.abs(close - open)

// HTF Trend Detection (Fast EMA > Slow EMA = bullish)
float htfFastEMA = ta.ema(close, fastLen)
float htfSlowEMA = ta.ema(close, slowLen)
bool htfBullTrend = htfFastEMA > htfSlowEMA
bool htfBearTrend = htfFastEMA < htfSlowEMA

// FVG Confluence Check Function
fvgNearOB(obTop, obBot, isBull) =>
    bool hasConfluence = false
    if isBull and array.size(bullFVGTops) > 0
        for i = 0 to array.size(bullFVGTops) - 1
            fvgTop = array.get(bullFVGTops, i)
            fvgBot = array.get(bullFVGBots, i)
            if (fvgBot <= obTop and fvgTop >= obBot)
                hasConfluence := true
    if not isBull and array.size(bearFVGTops) > 0
        for i = 0 to array.size(bearFVGTops) - 1
            fvgTop = array.get(bearFVGTops, i)
            fvgBot = array.get(bearFVGBots, i)
            if (fvgBot <= obTop and fvgTop >= obBot)
                hasConfluence := true
    hasConfluence

// OB Scoring Function (0-10)
calcOBScore(obBody, displacement, inKZ, htfAligned, hasFVG) =>
    int score = 0
    // +3 Strong displacement (move > 2x ATR)
    if displacement > atrVal * obATRMult
        score += 3
    // +2 First test (unmitigated - all new OBs are unmitigated)
    score += 2
    // +2 HTF trend aligned
    if htfAligned
        score += 2
    // +1 In killzone
    if inKZ
        score += 1
    // +1 FVG confluence
    if hasFVG
        score += 1
    // +1 Strong body
    if obBody > avgBody * 1.3
        score += 1
    math.min(score, 10)

// OB Color by Score
obColorByScore(score, isBull) =>
    if score >= 8
        isBull ? color.new(#00ff88, 60) : color.new(#ff4444, 60)  // Green/Red - High
    else if score >= 5
        isBull ? color.new(#00bcd4, 70) : color.new(#ff5252, 70)  // Cyan/Pink - Medium
    else
        color.new(color.gray, 80)  // Gray - Weak

// Create Bull OB with Scoring
if showOB and bosUp
    int idx = na
    for i = 1 to 10
        if close[i] < open[i]
            idx := i
            break
    if not na(idx)
        float obTop = high[idx]
        float obBot = low[idx]
        float obBody = math.abs(close[idx] - open[idx])
        float displacement = math.abs(close - close[idx])
        bool hasFVG = fvgNearOB(obTop, obBot, true)
        int obScore = calcOBScore(obBody, displacement, inKillzone, htfBullTrend, hasFVG)
        
        // Apply threshold filter
        if obScore >= obScoreThreshold or not hideWeakOBs
            string obLabel = showOBScore ? "â–® OB " + str.tostring(obScore) + "/10" : "â–® OB"
            if obScore >= 8
                obLabel := obLabel + " â˜…"
            int obWidth = obScore >= 8 ? 3 : obScore >= 5 ? 2 : 1
            color obBgCol = obColorByScore(obScore, true)
            color obBorderCol = obScore >= 5 ? color.new(#00bcd4, 20) : color.new(color.gray, 40)
            
            box b = box.new(bar_index - idx, obTop, bar_index + 60, obBot, border_color=obBorderCol, bgcolor=obBgCol, border_width=obWidth, text=obLabel, text_color=#00bcd4, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
            array.push(bullOBs, b)
            array.push(bullOBBots, obBot)
            array.push(bullOBScores, obScore)
            if array.size(bullOBs) > maxOB
                box.delete(array.shift(bullOBs))
                array.shift(bullOBBots)
                array.shift(bullOBScores)

// Create Bear OB with Scoring
if showOB and bosDn
    int idx = na
    for i = 1 to 10
        if close[i] > open[i]
            idx := i
            break
    if not na(idx)
        float obTop = high[idx]
        float obBot = low[idx]
        float obBody = math.abs(close[idx] - open[idx])
        float displacement = math.abs(close - close[idx])
        bool hasFVG = fvgNearOB(obTop, obBot, false)
        int obScore = calcOBScore(obBody, displacement, inKillzone, htfBearTrend, hasFVG)
        
        // Apply threshold filter
        if obScore >= obScoreThreshold or not hideWeakOBs
            string obLabel = showOBScore ? "â–® OB " + str.tostring(obScore) + "/10" : "â–® OB"
            if obScore >= 8
                obLabel := obLabel + " â˜…"
            int obWidth = obScore >= 8 ? 3 : obScore >= 5 ? 2 : 1
            color obBgCol = obColorByScore(obScore, false)
            color obBorderCol = obScore >= 5 ? color.new(#ff5252, 20) : color.new(color.gray, 40)
            
            box b = box.new(bar_index - idx, obTop, bar_index + 60, obBot, border_color=obBorderCol, bgcolor=obBgCol, border_width=obWidth, text=obLabel, text_color=#ff5252, text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
            array.push(bearOBs, b)
            array.push(bearOBTops, obTop)
            array.push(bearOBScores, obScore)
            if array.size(bearOBs) > maxOB
                box.delete(array.shift(bearOBs))
                array.shift(bearOBTops)
                array.shift(bearOBScores)

// â•â•â• ORDER BLOCK MITIGATION (Present Mode) â•â•â•
if presentMode and array.size(bullOBs) > 0
    for i = array.size(bullOBs) - 1 to 0
        if i < array.size(bullOBBots)
            float bot = array.get(bullOBBots, i)
            // Bull OB invalidated when price closes below
            if close < bot
                box.delete(array.get(bullOBs, i))
                array.remove(bullOBs, i)
                array.remove(bullOBBots, i)
                if i < array.size(bullOBScores)
                    array.remove(bullOBScores, i)

if presentMode and array.size(bearOBs) > 0
    for i = array.size(bearOBs) - 1 to 0
        if i < array.size(bearOBTops)
            float top = array.get(bearOBTops, i)
            // Bear OB invalidated when price closes above
            if close > top
                box.delete(array.get(bearOBs, i))
                array.remove(bearOBs, i)
                array.remove(bearOBTops, i)
                if i < array.size(bearOBScores)
                    array.remove(bearOBScores, i)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 7. KILLZONE SIGNALS (ZODIAC FILTERED) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// bodySize reused from line 450
bool disp = bodySize > avgBody * 1.5

// Base killzone signals
bool kzLongBase = inKillzone and isBullFVG and disp and close > open
bool kzShortBase = inKillzone and isBearFVG and disp and close < open

// Apply zodiac filter if enabled
bool kzLong = zodiacFilter ? (kzLongBase and bullishBias) : kzLongBase
bool kzShort = zodiacFilter ? (kzShortBase and bearishBias) : kzShortBase

// Strong signals (high score FVG + displacement + killzone aligned)
// Note: strongBullFVG/strongBearFVG replaced with hasDisplacement + killzone check
bool kzLongStrong = kzLong and hasDisplacement and inKillzone
bool kzShortStrong = kzShort and hasDisplacement and inKillzone

// Visual differentiation: Strong = â˜…, Weak = standard
plotshape(kzLongStrong, style=shape.labelup, location=location.belowbar, color=color.green, text="KZ â˜…", textcolor=color.white, size=size.normal)
plotshape(kzLong and not kzLongStrong, style=shape.labelup, location=location.belowbar, color=color.new(color.green, 40), text="KZ", textcolor=color.white, size=size.small)
plotshape(kzShortStrong, style=shape.labeldown, location=location.abovebar, color=color.red, text="KZ â˜…", textcolor=color.white, size=size.normal)
plotshape(kzShort and not kzShortStrong, style=shape.labeldown, location=location.abovebar, color=color.new(color.red, 40), text="KZ", textcolor=color.white, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 7B. CONFLUENCE DETECTION (AEP + ICT) â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AEP-style trend detection
float fastMA = ta.ema(close, fastLen)
float slowMA = ta.ema(close, slowLen)
float rsiVal = ta.rsi(close, rsiLen)

// MA alignment (AEP style)
bool fastUp = fastMA > fastMA[3]
bool fastDn = fastMA < fastMA[3]
bool slowUp = slowMA > slowMA[3]
bool slowDn = slowMA < slowMA[3]
bool aepBullAlign = fastMA > slowMA and fastUp and slowUp
bool aepBearAlign = fastMA < slowMA and fastDn and slowDn

// RSI confirmation
bool rsiNotOB = rsiVal < rsiOB  // Not overbought for longs
bool rsiNotOS = rsiVal > rsiOS  // Not oversold for shorts

// â•â•â• OB/FVG PROXIMITY CHECK FOR NUCLEAR â•â•â•
// Check if price is within 0.5 ATR of a high-score OB or FVG
float nuclearATR = ta.atr(14)
bool nearHighScoreBullOB = false
bool nearHighScoreBearOB = false
bool nearHighScoreBullFVG = false
bool nearHighScoreBearFVG = false

// Check bull OBs for proximity
if array.size(bullOBScores) > 0
    for i = 0 to array.size(bullOBScores) - 1
        if array.get(bullOBScores, i) >= obScoreThreshold
            float obBot = array.get(bullOBBots, i)
            if math.abs(close - obBot) < nuclearATR * 0.5
                nearHighScoreBullOB := true

// Check bear OBs for proximity
if array.size(bearOBScores) > 0
    for i = 0 to array.size(bearOBScores) - 1
        if array.get(bearOBScores, i) >= obScoreThreshold
            float obTop = array.get(bearOBTops, i)
            if math.abs(close - obTop) < nuclearATR * 0.5
                nearHighScoreBearOB := true

// Check FVGs for proximity
if array.size(bullFVGScores) > 0
    for i = 0 to array.size(bullFVGScores) - 1
        if array.get(bullFVGScores, i) >= fvgScoreThreshold
            float fvgBot = array.get(bullFVGBots, i)
            if math.abs(close - fvgBot) < nuclearATR * 0.5
                nearHighScoreBullFVG := true

if array.size(bearFVGScores) > 0
    for i = 0 to array.size(bearFVGScores) - 1
        if array.get(bearFVGScores, i) >= fvgScoreThreshold
            float fvgTop = array.get(bearFVGTops, i)
            if math.abs(close - fvgTop) < nuclearATR * 0.5
                nearHighScoreBearFVG := true

bool nearBullZone = nearHighScoreBullOB or nearHighScoreBullFVG
bool nearBearZone = nearHighScoreBearOB or nearHighScoreBearFVG

// â•â•â• NUCLEAR CONFLUENCE â•â•â•
// Both AEP (trend) and ICT (structure) agree on STRONG signals
// Enhanced: Require proximity to high-score OB/FVG
bool nuclearLong = enableConfluence and kzLongStrong and aepBullAlign and rsiNotOB and nearBullZone
bool nuclearShort = enableConfluence and kzShortStrong and aepBearAlign and rsiNotOS and nearBearZone

// Visual: Diamond marker for nuclear confluence
plotshape(nuclearLong, style=shape.diamond, location=location.belowbar, color=color.new(#FFD700, 0), text="ðŸ”¥ NUCLEAR", textcolor=color.white, size=size.large, offset=-1)
plotshape(nuclearShort, style=shape.diamond, location=location.abovebar, color=color.new(#FFD700, 0), text="ðŸ”¥ NUCLEAR", textcolor=color.white, size=size.large, offset=-1)

// Conflict detection (AEP and ICT disagree)
bool conflictLong = kzLongStrong and aepBearAlign  // ICT says long, AEP says bearish
bool conflictShort = kzShortStrong and aepBullAlign  // ICT says short, AEP says bullish

// â•â•â• CONFLICT WARNING LABELS â•â•â•
plotshape(conflictLong, style=shape.xcross, location=location.belowbar, color=color.new(color.orange, 0), text="âš  CONFLICT", textcolor=color.orange, size=size.small)
plotshape(conflictShort, style=shape.xcross, location=location.abovebar, color=color.new(color.orange, 0), text="âš  CONFLICT", textcolor=color.orange, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ 8. DASHBOARD â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var table dash = table.new(position.top_right, 2, 9, bgcolor=color.new(color.black, 60), border_width=1, border_color=color.gray)

if showZodiac and barstate.islast
    table.cell(dash, 0, 0, "ICT x AEP ðŸ”¥", text_color=color.white, text_size=size.small, bgcolor=elemCol)
    table.merge_cells(dash, 0, 0, 1, 0)
    
    string sess = inNYPM ? "ðŸŸ£ NY PM" : inNYLunch ? "ðŸŸ  NY LUNCH" : inNY ? "ðŸŸ¢ NY AM" : inLondon ? "ðŸ”´ LONDON" : inAsia ? "ðŸ”µ ASIA" : "â¸ï¸ OFF"
    color sessCol = inNYPM ? nyPMCol : inNYLunch ? nyLunchCol : inNY ? nyCol : inLondon ? londonCol : inAsia ? asiaCol : color.gray
    table.cell(dash, 0, 1, "Session", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 1, sess, text_color=sessCol, text_size=size.tiny)
    
    table.cell(dash, 0, 2, "Moon", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 2, moonPhase, text_color=color.white, text_size=size.tiny)
    
    table.cell(dash, 0, 3, "Sign", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 3, currentZodiac, text_color=elemCol, text_size=size.tiny)
    
    table.cell(dash, 0, 4, "Element", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 4, element, text_color=elemCol, text_size=size.tiny)
    
    table.cell(dash, 0, 5, "Profile", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 5, ictBias, text_color=color.yellow, text_size=size.tiny)
    
    table.cell(dash, 0, 6, "Focus", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 6, ictFocus, text_color=color.lime, text_size=size.tiny)
    
    table.cell(dash, 0, 7, "PDH", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 7, str.tostring(pdh, format.mintick), text_color=color.red, text_size=size.tiny)
    
    table.cell(dash, 0, 8, "PDL", text_color=color.white, text_size=size.tiny)
    table.cell(dash, 1, 8, str.tostring(pdl, format.mintick), text_color=color.green, text_size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘ ALERTS â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(kzLong, title="Killzone LONG", message="ðŸŽ¯ Killzone LONG")
alertcondition(kzShort, title="Killzone SHORT", message="ðŸŽ¯ Killzone SHORT")
alertcondition(nuclearLong, title="ðŸ”¥ NUCLEAR LONG", message="ðŸ”¥ NUCLEAR CONFLUENCE: AEP + ICT agree LONG!")
alertcondition(nuclearShort, title="ðŸ”¥ NUCLEAR SHORT", message="ðŸ”¥ NUCLEAR CONFLUENCE: AEP + ICT agree SHORT!")
alertcondition(bosUp, title="Bullish BOS", message="BOS UP")
alertcondition(bosDn, title="Bearish BOS", message="BOS DOWN")
alertcondition(londonSessionStart, title="London Open", message="London Session Started")
alertcondition(nySessionStart, title="NY Open", message="NY AM Session Started")

// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © AEP Protocol v3 - OPTIMIZED STRATEGY (More Trades, Tighter Risk)

//@version=5
strategy("AEP Protocol v3 [OPTIMIZED]", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, default_qty_value=1, currency=currency.USD, max_bars_back=1000)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ OPTIMIZATION NOTES ░░░
// ══════════════════════════════════════════════════════════════════════════════
// This variant includes the following tweaks vs. the base strategy:
// 1. Stop Factor: 1.0 → 0.8 (tighter risk, faster recovery from losses)
// 2. Block counter-trend: ON → OFF (catch reversals at S/D zones)
// 3. Momentum Body Mult: 1.3 → 1.1 (more trade signals)
// 4. Added NY Session filter option (focus on high-liquidity hours)
// ══════════════════════════════════════════════════════════════════════════════

// --- VISUAL ---
grpVis = "Visual"
bool showSignals = input.bool(true, "Show Signals", group=grpVis)
bool drawMAs = input.bool(true, "Draw MAs", group=grpVis)
bool fillBackground = input.bool(true, "Fill Background", group=grpVis)

// --- CORE ---
grpCore = "Core"
string maType = input.string("EMA", "MA Type", options=["EMA", "SMA", "WMA", "VWMA"], group=grpCore)
int fastLen = input.int(9, "Fast MA", minval=1, group=grpCore)
int slowLen = input.int(30, "Slow MA", minval=1, group=grpCore)
int rsiLen = input.int(14, "RSI Length", minval=2, group=grpCore)
int rsiOB = input.int(70, "RSI Overbought", minval=50, group=grpCore)
int rsiOS = input.int(25, "RSI Oversold", minval=0, group=grpCore)
bool enableMomentumLongs = input.bool(true, "Enable Momentum Longs", group=grpCore)
bool enableMomentumShorts = input.bool(true, "Enable Momentum Shorts", group=grpCore)

// --- CHOP ---
grpChop = "Consolidation"
float consolEMAPct = input.float(0.4, "Consolidation EMA %", minval=0.1, step=0.1, group=grpChop)
float consolMaxMovePct = input.float(0.6, "Consolidation Max Price Move %", minval=0.1, step=0.1, group=grpChop)
int rangeBarCount = input.int(20, "Range Bar Count", minval=5, group=grpChop)

// --- ORB ---
grpORB = "Breakouts"
bool orbEnabled = input.bool(true, "Enable ORB", group=grpORB)
string orbSession = input.session("0930-0945", "ORB Session (NY time)", group=grpORB)
string fullSession = input.session("0930-1600", "Full Trading Session", group=grpORB)
int orbHoldBars = input.int(15, "ORB Breakout Hold Bars", minval=1, group=grpORB)
// OPTIMIZED: Disabled to catch reversals at S/D zones
bool blockCounterTrend = input.bool(false, "Block counter-trend during ORB breakout", group=grpORB)
float orbRetestTol = input.float(30.0, "ORB Retest Tolerance %", minval=1.0, group=grpORB)
int maxBarsRetest = input.int(25, "Max Bars After ORB For Retest", minval=5, group=grpORB)

// --- SESSION FILTER (NEW) ---
grpSession = "Session Filter"
bool useSessionFilter = input.bool(false, "Only trade during NY session", group=grpSession)
string tradeSession = input.session("0930-1600", "Trading Hours (NY time)", group=grpSession)

// --- ADVANCED ---
grpAdv = "Advanced"
int volumePeriod = input.int(10, "Volume Period", minval=1, group=grpAdv)
// OPTIMIZED: Lowered from 1.3 to 1.1 for more signals
float momentumBodyMult = input.float(1.1, "Momentum Body Multiplier", minval=0.5, step=0.1, group=grpAdv)

// --- RISK ---
grpRisk = "Risk"
float profitFactor = input.float(2.0, "Profit Factor", minval=0.5, step=0.5, group=grpRisk)
// OPTIMIZED: Tightened from 1.0 to 0.8 for faster loss recovery
float stopFactor = input.float(0.8, "Stop Factor", minval=0.5, step=0.1, group=grpRisk)


// ══════════════════════════════════════════════════════════════════════════════
// ░░░ CALCULATIONS ░░░
// ══════════════════════════════════════════════════════════════════════════════

// Session Check
bool inTradeSession = useSessionFilter ? time(timeframe.period, tradeSession, "America/New_York") : true

// MA & RSI
ma(src, len, t) =>
    switch t
        "EMA" => ta.ema(src, len)
        "SMA" => ta.sma(src, len)
        "WMA" => ta.wma(src, len)
        "VWMA" => ta.vwma(src, len)
        => ta.ema(src, len)

float fastMA = ma(close, fastLen, maType)
float slowMA = ma(close, slowLen, maType)
float rsiVal = ta.rsi(close, rsiLen)

// Alignment
bool fastUp = fastMA > fastMA[3]
bool slowUp = slowMA > slowMA[3]
bool fastDn = fastMA < fastMA[3]
bool slowDn = slowMA < slowMA[3]
bool bullAlign = fastMA > slowMA and fastUp and slowUp
bool bearAlign = fastMA < slowMA and fastDn and slowDn

// Chop
float maDistPct = (math.abs(fastMA - slowMA) / close) * 100
float rangeHi = ta.highest(high, rangeBarCount)
float rangeLo = ta.lowest(low, rangeBarCount)
float rangeMovePct = ((rangeHi - rangeLo) / rangeLo) * 100
bool isChop = maDistPct < consolEMAPct or rangeMovePct < consolMaxMovePct

// Momentum Logic
float avgVol = ta.sma(volume, volumePeriod)
bool volConfirm = volume > avgVol

float bodySize = math.abs(close - open)
float avgBody = ta.sma(bodySize, 3)
bool strongBody = bodySize > avgBody * momentumBodyMult
bool breakPrevHigh = close > high[1]
bool breakPrevLow = close < low[1]

bool pullbackLong = bullAlign and close < fastMA and close > slowMA
bool pullbackShort = bearAlign and close > fastMA and close < slowMA


// ══════════════════════════════════════════════════════════════════════════════
// ░░░ ORB LOGIC ░░░
// ══════════════════════════════════════════════════════════════════════════════
bool inORB = time(timeframe.period, orbSession, "America/New_York")
var float orbHigh = na
var float orbLow = na
var bool orbComplete = false
var int orbBarStart = na
var int orbDayKey = na

if dayofweek != orbDayKey
    orbHigh := na
    orbLow := na
    orbComplete := false
    orbBarStart := na
    orbDayKey := dayofweek

if inORB and orbEnabled
    orbHigh := na(orbHigh) ? high : math.max(orbHigh, high)
    orbLow := na(orbLow) ? low : math.min(orbLow, low)
    if na(orbBarStart)
        orbBarStart := bar_index
    if not na(orbHigh) and not na(orbLow)
        orbComplete := true

var int orbBreakDir = 0
var int orbBreakBar = na

if orbComplete and not inORB and orbEnabled
    if ta.crossover(close, orbHigh) and orbBreakDir == 0
        orbBreakDir := 1
        orbBreakBar := bar_index
    if ta.crossunder(close, orbLow) and orbBreakDir == 0
        orbBreakDir := -1
        orbBreakBar := bar_index

if dayofweek != dayofweek[1]
    orbBreakDir := 0
    orbBreakBar := na

int barsSinceBreak = na(orbBreakBar) ? 999 : bar_index - orbBreakBar


// ══════════════════════════════════════════════════════════════════════════════
// ░░░ SIGNALS ░░░
// ══════════════════════════════════════════════════════════════════════════════

bool longBase = bullAlign and not isChop and close > fastMA and volConfirm and strongBody
bool longMomo = bullAlign and close > fastMA and strongBody and breakPrevHigh and not isChop and enableMomentumLongs
bool longPullbackExit = pullbackLong[1] and close > fastMA and not isChop
bool longSignal = (longBase or longMomo or longPullbackExit) and inTradeSession

bool shortBase = bearAlign and not isChop and close < fastMA and volConfirm and strongBody
bool shortMomo = bearAlign and close < fastMA and strongBody and breakPrevLow and not isChop and enableMomentumShorts
bool shortPullbackExit = pullbackShort[1] and close < fastMA and not isChop
bool shortSignal = (shortBase or shortMomo or shortPullbackExit) and inTradeSession

// ORB Gate (OPTIMIZED: blockCounterTrend defaults to OFF)
if blockCounterTrend and orbEnabled and orbComplete and barsSinceBreak <= orbHoldBars
    if orbBreakDir == 1
        shortSignal := false
    if orbBreakDir == -1
        longSignal := false

// Chop Block
if isChop
    longSignal := false
    shortSignal := false


// ══════════════════════════════════════════════════════════════════════════════
// ░░░ STRATEGY EXECUTION ░░░
// ══════════════════════════════════════════════════════════════════════════════

// ATR Calculation for Stops/Targets
float atrVal = ta.atr(14)

// ENTRY
if longSignal and strategy.position_size == 0
    strategy.entry("Long", strategy.long, comment="AEP L")
    
if shortSignal and strategy.position_size == 0
    strategy.entry("Short", strategy.short, comment="AEP S")

// EXIT LOGIC (ATR Dynamic with OPTIMIZED stop factor)
if strategy.position_size > 0
    float entryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)
    float lStop = entryPrice - (atrVal * stopFactor)
    float lTarget = entryPrice + (atrVal * profitFactor)
    strategy.exit("Exit Long", "Long", stop=lStop, limit=lTarget, comment_loss="SL", comment_profit="TP")

if strategy.position_size < 0
    float entryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)
    float sStop = entryPrice + (atrVal * stopFactor)
    float sTarget = entryPrice - (atrVal * profitFactor)
    strategy.exit("Exit Short", "Short", stop=sStop, limit=sTarget, comment_loss="SL", comment_profit="TP")

// REVERSAL LOGIC
if longSignal and strategy.position_size < 0
    strategy.close("Short", comment="Flip L")
    strategy.entry("Long", strategy.long, comment="AEP L (Flip)")

if shortSignal and strategy.position_size > 0
    strategy.close("Long", comment="Flip S")
    strategy.entry("Short", strategy.short, comment="AEP S (Flip)")

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ VISUALS ░░░
// ══════════════════════════════════════════════════════════════════════════════
plot(drawMAs ? fastMA : na, "Fast MA", color=color.blue)
plot(drawMAs ? slowMA : na, "Slow MA", color=color.orange)
bgcolor(fillBackground ? (isChop ? color.new(color.gray, 90) : bullAlign ? color.new(color.green, 92) : bearAlign ? color.new(color.red, 92) : na) : na)

// Session highlight
bgcolor(useSessionFilter and not inTradeSession ? color.new(color.red, 95) : na, title="Outside Session")

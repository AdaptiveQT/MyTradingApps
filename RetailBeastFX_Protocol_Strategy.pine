// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © RetailBeastFX Protocol - Strategy Version for Backtesting [DUAL-MODE]

//@version=5
strategy("RetailBeastFX Protocol [Strategy]", overlay=true, initial_capital=100000, default_qty_type=strategy.percent_of_equity, default_qty_value=10, currency=currency.USD, calc_on_every_tick=true)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ SYSTEM MODE ░░░
// ══════════════════════════════════════════════════════════════════════════════

grpMode = "System Mode"
string mode = input.string("Standard", "Configuration Mode", options=["Standard", "Optimized", "Custom"], group=grpMode, 
 tooltip="Standard: Original Logic (Safe, Trend-Following)\nOptimized: Enhanced Logic (Aggressive, Reversals, Tighter Risk)\nCustom: Use manual settings below")

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ CORE SETTINGS ░░░
// ══════════════════════════════════════════════════════════════════════════════

grpCore = "Core Trend System"
string maType = input.string("EMA", "MA Type", options=["EMA", "SMA", "WMA", "VWMA"], group=grpCore)
int fastLen = input.int(9, "Fast MA Length", minval=1, group=grpCore, tooltip="Faster moving average for short-term trend")
int slowLen = input.int(30, "Slow MA Length", minval=1, group=grpCore, tooltip="Slower moving average for long-term trend")
int rsiLen = input.int(14, "RSI Length", minval=2, group=grpCore)
int rsiOB = input.int(70, "RSI Overbought", minval=50, maxval=100, group=grpCore)
int rsiOS = input.int(25, "RSI Oversold", minval=0, maxval=50, group=grpCore)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ CONSOLIDATION DETECTION ░░░
// ══════════════════════════════════════════════════════════════════════════════

grpChop = "Consolidation Filter"
float consolEMAPct = input.float(0.4, "EMA Distance Threshold %", minval=0.1, step=0.1, group=grpChop, 
 tooltip="When MAs are closer than this %, market is consolidating")
float consolMaxMovePct = input.float(0.6, "Max Range Move %", minval=0.1, step=0.1, group=grpChop,
 tooltip="Maximum price movement % to be considered consolidation")
int rangeBarCount = input.int(20, "Range Lookback Bars", minval=5, group=grpChop)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ OPENING RANGE BREAKOUT (ORB) ░░░
// ══════════════════════════════════════════════════════════════════════════════

grpORB = "Opening Range Breakout"
bool orbEnabled = input.bool(true, "Enable ORB System", group=grpORB)
string orbSession = input.session("0930-0945", "ORB Session (NY Time)", group=grpORB,
 tooltip="The opening 15 minutes establishes the range")
string tradingSession = input.session("0930-1600", "Trading Session", group=grpORB)
int orbHoldBars = input.int(15, "ORB Momentum Bars", minval=1, group=grpORB,
 tooltip="How many bars to ride the ORB breakout momentum")

// MODE CONTROLLED INPUTS
bool _blockCounterTrend = input.bool(true, "Block Counter-Trend During ORB", group=grpORB,
 tooltip="[Standard: ON, Optimized: OFF] Prevent short signals during bullish ORB breakout")
bool finalBlockCT = mode == "Standard" ? true : mode == "Optimized" ? false : _blockCounterTrend

bool showORBLines = input.bool(true, "Show ORB Range Lines", group=grpORB)
float orbRetestTol = input.float(30.0, "Retest Tolerance %", minval=1.0, step=0.5, group=grpORB,
 tooltip="How close price needs to get to ORB levels for retest signal")
int maxBarsRetest = input.int(25, "Max Bars for Retest", minval=5, group=grpORB)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ SESSION FILTER (MODE CONTROLLED) ░░░
// ══════════════════════════════════════════════════════════════════════════════

grpSession = "Session Filter"
bool _useSessionFilter = input.bool(true, "Enforce Trading Session", group=grpSession, 
 tooltip="[Standard: ON, Optimized: OFF] If OFF, trades 24/7. If ON, only trades during 'Trading Session'")
bool finalUseSession = mode == "Standard" ? true : mode == "Optimized" ? false : _useSessionFilter

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ SUPPLY & DEMAND ZONES ░░░
// ══════════════════════════════════════════════════════════════════════════════

grpSD = "Supply & Demand Zones"
bool showSDZones = input.bool(true, "Show S/D Zones", group=grpSD)
int pivotLeft = input.int(10, "Pivot Strength (Left)", minval=1, group=grpSD,
 tooltip="More bars = stronger but fewer pivots")
int pivotRight = input.int(3, "Pivot Confirmation (Right)", minval=1, group=grpSD)
int maxLevels = input.int(20, "Max Active Zones", minval=5, group=grpSD)
int zoneHeightTicks = input.int(28, "Zone Height (Ticks)", minval=1, group=grpSD)
bool showZoneLabels = input.bool(true, "Show Zone Labels", group=grpSD)
color supplyColor = input.color(color.new(color.red, 80), "Supply Color", group=grpSD)
color demandColor = input.color(color.new(color.blue, 80), "Demand Color", group=grpSD)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ VOLUME & MOMENTUM ░░░
// ══════════════════════════════════════════════════════════════════════════════

grpMomentum = "Volume & Momentum"
int volumePeriod = input.int(8, "Volume Average Period", minval=1, group=grpMomentum)

// MODE CONTROLLED INPUTS
float _momentumBodyMult = input.float(1.2, "Strong Candle Body Multiplier", minval=0.5, step=0.1, group=grpMomentum,
 tooltip="[Standard: 1.2, Optimized: 1.1] Candle body must be this many times larger than average")
float finalMomMult = mode == "Standard" ? 1.2 : mode == "Optimized" ? 1.1 : _momentumBodyMult

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ RISK MANAGEMENT ░░░
// ══════════════════════════════════════════════════════════════════════════════

grpRisk = "Risk Management"
float profitFactor = input.float(2.0, "Profit Target (R:R)", minval=0.5, step=0.5, group=grpRisk,
 tooltip="Profit target as multiple of ATR (e.g., 2.0 = 2:1 R:R)")

// MODE CONTROLLED INPUTS
float _stopFactor = input.float(1.0, "Stop Loss Factor", minval=0.5, step=0.1, group=grpRisk,
 tooltip="[Standard: 1.0, Optimized: 0.8] Stop loss as multiple of ATR")
float finalStopFact = mode == "Standard" ? 1.0 : mode == "Optimized" ? 0.8 : _stopFactor

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ VISUAL SETTINGS ░░░
// ══════════════════════════════════════════════════════════════════════════════

grpVis = "Visual Settings"
bool showSignals = input.bool(true, "Show Entry Signals", group=grpVis)
bool drawMAs = input.bool(true, "Draw Moving Averages", group=grpVis)
bool fillBackground = input.bool(true, "Fill Background", group=grpVis)
bool showDashboard = input.bool(true, "Show Dashboard", group=grpVis)
color bullishCol = input.color(color.green, "Bullish Color", group=grpVis)
color bearishCol = input.color(color.red, "Bearish Color", group=grpVis)
color neutralCol = input.color(color.gray, "Neutral Color", group=grpVis)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ CALCULATIONS ░░░
// ══════════════════════════════════════════════════════════════════════════════

// --- Moving Averages ---
ma(src, len, type) =>
    switch type
        "EMA" => ta.ema(src, len)
        "SMA" => ta.sma(src, len)
        "WMA" => ta.wma(src, len)
        "VWMA" => ta.vwma(src, len)
        => ta.ema(src, len)

float fastMA = ma(close, fastLen, maType)
float slowMA = ma(close, slowLen, maType)
float rsiVal = ta.rsi(close, rsiLen)

// --- Trend Alignment ---
bool fastUp = fastMA > fastMA[3]
bool fastDn = fastMA < fastMA[3]
bool slowUp = slowMA > slowMA[3]
bool slowDn = slowMA < slowMA[3]

bool bullAlign = fastMA > slowMA and fastUp and slowUp
bool bearAlign = fastMA < slowMA and fastDn and slowDn

// --- Consolidation Detection ---
float maDistPct = (math.abs(fastMA - slowMA) / close) * 100
float rangeHi = ta.highest(high, rangeBarCount)
float rangeLo = ta.lowest(low, rangeBarCount)
float rangeMovePct = ((rangeHi - rangeLo) / rangeLo) * 100

bool isChop = maDistPct < consolEMAPct or rangeMovePct < consolMaxMovePct

// --- Pullback Detection ---
bool pullbackLong = bullAlign and close < fastMA and close > slowMA
bool pullbackShort = bearAlign and close > fastMA and close < slowMA

// --- Volume & Momentum ---
float avgVol = ta.sma(volume, volumePeriod)
bool volConfirm = volume > avgVol

float bodySize = math.abs(close - open)
float avgBody = ta.sma(bodySize, 3)
bool strongBody = bodySize > avgBody * finalMomMult // Using dynamic multiplier

bool breakPrevHigh = close > high[1]
bool breakPrevLow = close < low[1]

// --- Market State ---
string mktState = isChop ? "CONSOLIDATION" : bullAlign ? "BULLISH" : bearAlign ? "BEARISH" : "NEUTRAL"

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ OPENING RANGE BREAKOUT LOGIC ░░░
// ══════════════════════════════════════════════════════════════════════════════

bool inORB = not na(time(timeframe.period, orbSession, "America/New_York"))
// DYNAMIC SESSION CHECK: If finalUseSession is false, we are always 'inSession'
bool inSession = finalUseSession ? not na(time(timeframe.period, tradingSession, "America/New_York")) : true

var float orbHigh = na
var float orbLow = na
var bool orbComplete = false
var int orbBarStart = na
var int orbDayKey = na

// Reset ORB on new day
if dayofweek != orbDayKey
    orbHigh := na
    orbLow := na
    orbComplete := false
    orbBarStart := na
    orbDayKey := dayofweek

// Build ORB range during session
if inORB and orbEnabled
    orbHigh := na(orbHigh) ? high : math.max(orbHigh, high)
    orbLow := na(orbLow) ? low : math.min(orbLow, low)
    if na(orbBarStart)
        orbBarStart := bar_index
    if not na(orbHigh) and not na(orbLow)
        orbComplete := true

// Track ORB breakout direction
var int orbBreakDir = 0  // 0=none, 1=bullish, -1=bearish
var int orbBreakBar = na

bool crossAboveORBHigh = ta.crossover(close, orbHigh)
bool crossBelowORBLow = ta.crossunder(close, orbLow)

if orbComplete and not inORB and orbEnabled
    if crossAboveORBHigh and orbBreakDir == 0
        orbBreakDir := 1
        orbBreakBar := bar_index
    if crossBelowORBLow and orbBreakDir == 0
        orbBreakDir := -1
        orbBreakBar := bar_index

// Reset breakout direction on new day
if dayofweek != dayofweek[1]
    orbBreakDir := 0
    orbBreakBar := na

// Calculate bars since ORB breakout
int barsSinceBreak = na(orbBreakBar) ? 999 : bar_index - orbBreakBar
bool inRetestWindow = barsSinceBreak <= maxBarsRetest

// ORB Retest Detection
float retestTolAmt = (orbHigh - orbLow) * (orbRetestTol / 100)

bool orbRetestLong = orbBreakDir == 1 and inRetestWindow and 
 low <= orbHigh + retestTolAmt and low >= orbHigh - retestTolAmt

bool orbRetestShort = orbBreakDir == -1 and inRetestWindow and 
 high >= orbLow - retestTolAmt and high <= orbLow + retestTolAmt

// ORB Midline
var float orbMid = na
if orbComplete
    orbMid := math.avg(orbHigh, orbLow)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ ORB VISUALIZATION ░░░
// ══════════════════════════════════════════════════════════════════════════════

var box orbBox = na
var line orbHighLine = na
var line orbLowLine = na
var line orbMidLine = na
var label orbMidLabel = na

bool canDrawORB = not na(orbBarStart) and (last_bar_index - orbBarStart) < 450

if orbComplete and not inORB and inORB[1] and showORBLines and orbEnabled and canDrawORB
    orbBox := box.new(orbBarStart, orbHigh, bar_index, orbLow, 
     border_color=color.new(color.purple, 50), bgcolor=color.new(color.purple, 90), border_width=1)
    orbHighLine := line.new(bar_index, orbHigh, bar_index + 100, orbHigh, 
     color=color.new(color.green, 40), style=line.style_dashed, width=2)
    orbLowLine := line.new(bar_index, orbLow, bar_index + 100, orbLow, 
     color=color.new(color.red, 40), style=line.style_dashed, width=2)
    orbMidLine := line.new(bar_index, orbMid, bar_index + 200, orbMid, 
     color=color.new(color.purple, 30), style=line.style_dotted, width=1)
    orbMidLabel := label.new(bar_index + 205, orbMid, "ORB 50%", 
     style=label.style_none, textcolor=color.purple, size=size.tiny)

if orbComplete and not na(orbHighLine) and showORBLines
    line.set_x2(orbHighLine, bar_index + 1)
    line.set_x2(orbLowLine, bar_index + 1)
    if not na(orbMidLine)
        line.set_x2(orbMidLine, bar_index + 1)
        label.set_x(orbMidLabel, bar_index + 5)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ SUPPLY & DEMAND ZONES ░░░
// ══════════════════════════════════════════════════════════════════════════════

float pivHi = ta.pivothigh(high, pivotLeft, pivotRight)
float pivLo = ta.pivotlow(low, pivotLeft, pivotRight)
float tickSize = syminfo.mintick
float zoneHeight = zoneHeightTicks * tickSize

var box[] supplyBoxes = array.new_box()
var box[] demandBoxes = array.new_box()
var label[] supplyLabels = array.new_label()
var label[] demandLabels = array.new_label()

int maxBoxLookback = 450
bool canDrawBox = (last_bar_index - bar_index) < maxBoxLookback

// Create Supply Zone (Resistance)
if not na(pivHi) and showSDZones and bar_index > pivotRight and canDrawBox
    int leftBar = bar_index - pivotRight
    int rightBar = bar_index + 50
    float zTop = pivHi
    float zBot = pivHi - zoneHeight
    
    box newBox = box.new(leftBar, zTop, rightBar, zBot, 
     border_color=color.new(color.red, 50), bgcolor=supplyColor, border_width=1)
    array.push(supplyBoxes, newBox)
    
    if showZoneLabels
        label newLbl = label.new(leftBar, zTop, "SUPPLY", 
         style=label.style_label_down, color=color.new(color.red, 30), 
         textcolor=color.white, size=size.tiny)
        array.push(supplyLabels, newLbl)
    
    if array.size(supplyBoxes) > maxLevels
        box.delete(array.shift(supplyBoxes))
        if array.size(supplyLabels) > 0
            label.delete(array.shift(supplyLabels))

// Create Demand Zone (Support)
if not na(pivLo) and showSDZones and bar_index > pivotRight and canDrawBox
    int leftBar = bar_index - pivotRight
    int rightBar = bar_index + 50
    float zBot = pivLo
    float zTop = pivLo + zoneHeight
    
    box newBox = box.new(leftBar, zTop, rightBar, zBot, 
     border_color=color.new(color.blue, 50), bgcolor=demandColor, border_width=1)
    array.push(demandBoxes, newBox)
    
    if showZoneLabels
        label newLbl = label.new(leftBar, zBot, "DEMAND", 
         style=label.style_label_up, color=color.new(color.blue, 30), 
         textcolor=color.white, size=size.tiny)
        array.push(demandLabels, newLbl)
    
    if array.size(demandBoxes) > maxLevels
        box.delete(array.shift(demandBoxes))
        if array.size(demandLabels) > 0
            label.delete(array.shift(demandLabels))

// Cleanup broken zones
if showSDZones and array.size(supplyBoxes) > 0
    for i = array.size(supplyBoxes) - 1 to 0
        box b = array.get(supplyBoxes, i)
        if close > box.get_top(b)
            box.set_bgcolor(b, color.new(color.red, 95))
            box.delete(b)
            array.remove(supplyBoxes, i)
            if i < array.size(supplyLabels)
                label.delete(array.get(supplyLabels, i))
                array.remove(supplyLabels, i)

if showSDZones and array.size(demandBoxes) > 0
    for i = array.size(demandBoxes) - 1 to 0
        box b = array.get(demandBoxes, i)
        if close < box.get_bottom(b)
            box.set_bgcolor(b, color.new(color.blue, 95))
            box.delete(b)
            array.remove(demandBoxes, i)
            if i < array.size(demandLabels)
                label.delete(array.get(demandLabels, i))
                array.remove(demandLabels, i)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ ENTRY SIGNAL LOGIC ░░░
// ══════════════════════════════════════════════════════════════════════════════

// Base entry conditions
bool longBase = bullAlign and not isChop and close > fastMA and volConfirm and strongBody
bool shortBase = bearAlign and not isChop and close < fastMA and volConfirm and strongBody

// Momentum entries
bool longMomo = bullAlign and close > fastMA and strongBody and breakPrevHigh and not isChop
bool shortMomo = bearAlign and close < fastMA and strongBody and breakPrevLow and not isChop

// Pullback entries
bool longPullbackEntry = pullbackLong[1] and close > fastMA and not isChop
bool shortPullbackEntry = pullbackShort[1] and close < fastMA and not isChop

// ORB retest entries
bool longRetestEntry = orbRetestLong and bullAlign and not isChop
bool shortRetestEntry = orbRetestShort and bearAlign and not isChop

// Combine all long signals
bool longSignal = (longBase or longMomo or longPullbackEntry or longRetestEntry) and showSignals and inSession

// Combine all short signals
bool shortSignal = (shortBase or shortMomo or shortPullbackEntry or shortRetestEntry) and showSignals and inSession

// Apply ORB momentum gate
// USING DYNAMIC BLOCK CT: finalBlockCT
if finalBlockCT and orbEnabled and orbComplete and barsSinceBreak <= orbHoldBars
    if orbBreakDir == 1
        shortSignal := false  // Block shorts during bullish ORB breakout
    if orbBreakDir == -1
        longSignal := false   // Block longs during bearish ORB breakout

// Block signals during consolidation
if isChop
    longSignal := false
    shortSignal := false

// Prevent duplicate signals (REMOVED for strategy to allow scaling/re-entry logic if desired, 
// though built-in strategy calls handle this. Keeping clean for logic)
// longSignal := longSignal and not longSignal[1]
// shortSignal := shortSignal and not shortSignal[1]

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ TARGET & STOP CALCULATION ░░░
// ══════════════════════════════════════════════════════════════════════════════

float atrVal = ta.atr(14)

var float longTarget = na
var float longStop = na
var float shortTarget = na
var float shortStop = na

// USING DYNAMIC STOP FACTOR: finalStopFact
if longSignal
    longStop := close - atrVal * finalStopFact
    longTarget := close + atrVal * profitFactor
    shortTarget := na
    shortStop := na

if shortSignal
    shortStop := close + atrVal * finalStopFact
    shortTarget := close - atrVal * profitFactor
    longTarget := na
    longStop := na

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ STRATEGY EXECUTION ░░░
// ══════════════════════════════════════════════════════════════════════════════

if longSignal
    strategy.entry("Long", strategy.long, comment="L")
    strategy.exit("Exit Long", "Long", limit=longTarget, stop=longStop, comment_profit="TP", comment_loss="SL")

if shortSignal
    strategy.entry("Short", strategy.short, comment="S")
    strategy.exit("Exit Short", "Short", limit=shortTarget, stop=shortStop, comment_profit="TP", comment_loss="SL")

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ VISUALIZATION ░░░
// ══════════════════════════════════════════════════════════════════════════════

// Plot Moving Averages
plot(drawMAs ? fastMA : na, "Fast MA", color=color.blue, linewidth=2)
plot(drawMAs ? slowMA : na, "Slow MA", color=color.orange, linewidth=2)

// Background Color
color bgCol = isChop ? color.new(neutralCol, 92) : 
 bullAlign ? color.new(bullishCol, 94) : 
 bearAlign ? color.new(bearishCol, 94) : 
 color.new(neutralCol, 96)

bgcolor(fillBackground ? bgCol : na, title="Trend Background")

// Pullback bar coloring
barcolor(pullbackLong ? color.new(color.orange, 40) : 
 pullbackShort ? color.new(color.orange, 40) : na)

// ══════════════════════════════════════════════════════════════════════════════
// ░░░ DASHBOARD ░░░
// ══════════════════════════════════════════════════════════════════════════════

var table dash = table.new(position.top_right, 2, 8, 
 bgcolor=color.new(color.black, 85), border_width=2, border_color=color.gray)

if barstate.islast and showDashboard
    // Header
    table.cell(dash, 0, 0, "RetailBeastFX (" + mode + ")", text_color=color.white, 
     text_size=size.normal, bgcolor=color.new(color.blue, 50))
    table.merge_cells(dash, 0, 0, 1, 0)
    
    // Market State
    color stCol = isChop ? neutralCol : bullAlign ? bullishCol : bearAlign ? bearishCol : neutralCol
    table.cell(dash, 0, 1, "Market", text_color=color.white, text_size=size.small)
    table.cell(dash, 1, 1, mktState, text_color=stCol, text_size=size.small)
    
    // Trend Alignment
    string trendTxt = bullAlign ? "BULLISH ↑" : bearAlign ? "BEARISH ↓" : "NEUTRAL →"
    color trendCol = bullAlign ? bullishCol : bearAlign ? bearishCol : neutralCol
    table.cell(dash, 0, 2, "Trend", text_color=color.white, text_size=size.small)
    table.cell(dash, 1, 2, trendTxt, text_color=trendCol, text_size=size.small)
    
    // RSI
    color rsiCol = rsiVal > rsiOB ? bearishCol : rsiVal < rsiOS ? bullishCol : neutralCol
    string rsiLabel = rsiVal > rsiOB ? "OB" : rsiVal < rsiOS ? "OS" : "NEUTRAL"
    table.cell(dash, 0, 3, "RSI", text_color=color.white, text_size=size.small)
    table.cell(dash, 1, 3, str.tostring(rsiVal, "#.0") + " (" + rsiLabel + ")", 
     text_color=rsiCol, text_size=size.small)
    
    // ORB Status
    string orbTxt = not orbEnabled ? "DISABLED" : 
     not orbComplete ? "BUILDING" : 
     orbBreakDir == 1 ? "LONG BREAKOUT" : 
     orbBreakDir == -1 ? "SHORT BREAKOUT" : 
     "RANGING"
    color orbCol = orbBreakDir == 1 ? bullishCol : 
     orbBreakDir == -1 ? bearishCol : neutralCol
    table.cell(dash, 0, 4, "ORB", text_color=color.white, text_size=size.small)
    table.cell(dash, 1, 4, orbTxt, text_color=orbCol, text_size=size.small)
    
    // Volume Status
    string volTxt = volConfirm ? "HIGH ✓" : "LOW"
    color volCol = volConfirm ? bullishCol : neutralCol
    table.cell(dash, 0, 5, "Volume", text_color=color.white, text_size=size.small)
    table.cell(dash, 1, 5, volTxt, text_color=volCol, text_size=size.small)
    
    // Active Zones
    string zonesTxt = str.tostring(array.size(supplyBoxes)) + " Supply / " + 
     str.tostring(array.size(demandBoxes)) + " Demand"
    table.cell(dash, 0, 6, "S/D Zones", text_color=color.white, text_size=size.small)
    table.cell(dash, 1, 6, zonesTxt, text_color=color.aqua, text_size=size.small)
    
    // Session Status
    string sessionTxt = inSession ? "ACTIVE (" + (finalUseSession ? "NY" : "24/7") + ")" : "CLOSED"
    color sessionCol = inSession ? bullishCol : neutralCol
    table.cell(dash, 0, 7, "Session", text_color=color.white, text_size=size.small)
    table.cell(dash, 1, 7, sessionTxt, text_color=sessionCol, text_size=size.small)
